"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmapiClient = exports.SmapiClientErrors = void 0;
const node_fetch_1 = __importStar(require("node-fetch"));
const fast_xml_parser_1 = require("fast-xml-parser");
const debug_1 = __importDefault(require("debug"));
const smapi_error_1 = __importDefault(require("./smapi-error"));
const array_helper_1 = __importDefault(require("../helpers/array-helper"));
var SmapiClientErrors;
(function (SmapiClientErrors) {
    SmapiClientErrors["TokenRefreshRequiredError"] = "tokenRefreshRequired";
})(SmapiClientErrors = exports.SmapiClientErrors || (exports.SmapiClientErrors = {}));
/**
 * Sonos mucis service client, use GetMetadata as a starting point.
 *
 * @export
 * @remarks You shouldn't initialize yourself, take the one from sonos.MusicServicesClient('serviceName') because you'll need a lot of data know by sonos only.
 * @class SmapiClient
 */
class SmapiClient {
    constructor(options) {
        this.options = options;
        this.key = options.key;
        this.authToken = options.authToken;
    }
    get debug() {
        if (this.debugger === undefined)
            this.debugger = debug_1.default(`sonos:smapi:${this.options.name}`);
        return this.debugger;
    }
    async GetLoginLink() {
        var _a;
        if (this.options.auth === 'AppLink') {
            const appLink = await this.GetAppLink();
            if (appLink.authorizeAccount !== undefined) {
                return (_a = appLink.authorizeAccount) === null || _a === void 0 ? void 0 : _a.deviceLink;
            }
        }
        if (this.options.auth === 'DeviceLink') {
            return await this.GetDeviceLinkCode();
        }
        throw new Error('Login not supported for this service');
    }
    /**
     * Get the AppLink for this music service, to connect it to your sonos system.
     * Only for services with Auth == 'AppLink'
     *
     * @returns {Promise<AppLinkResponse>}
     * @memberof SmapiClient
     */
    async GetAppLink() {
        return await this.SoapRequestWithBody('getAppLink', {
            householdId: this.getHouseholdIdOrThrow(),
        });
    }
    /**
     * Get credentials for the remote service, you'll need the linkcode from GetAppLink
     *
     * @param {string} linkCode
     * @returns
     * @memberof SmapiClient
     */
    async GetDeviceAuthToken(linkCode) {
        return await this.SoapRequestWithBody('getDeviceAuthToken', {
            householdId: this.getHouseholdIdOrThrow(),
            linkCode,
            linkDeviceId: this.options.deviceId,
        })
            .then(async (data) => {
            if (this.options.saveNewAccount !== undefined) { // Save the account by the library provided way.
                await this.options.saveNewAccount(this.options.serviceId, data.privateKey, data.authToken);
            }
            return data;
        });
    }
    async GetDeviceLinkCode() {
        return await this.SoapRequestWithBody('getDeviceLinkCode', {
            householdId: this.getHouseholdIdOrThrow(),
        });
    }
    /**
     * This is the main entrypoint for the external Music service.
     * You can browse lists, sometimes referring to other lists.
     *
     * @param {string} input.id The ID where you want the media info for. 'root' for the initial list.
     * @param {number} input.index Where you want to start in the list, 0 is a good start.
     * @param {number} input.count How many items you want, use something sensible like 10.
     * @param {boolean?} input.recursive optional, If true, the music service should return a flat collection of track metadata.
     * @returns {Promise<any>}
     * @memberof SmapiClient
     */
    async GetMetadata(input) {
        return await this.SoapRequestWithBody('getMetadata', input).then((resp) => this.PostProcessMediaResult(resp));
    }
    async GetExtendedMetadata(input) {
        return await this.SoapRequestWithBody('getExtendedMetadata', input).then((resp) => this.PostProcessMediaResult(resp));
    }
    async GetMediaMetadata(input) {
        return await this.SoapRequestWithBody('getMediaMetadata', input);
    }
    async GetMediaUri(input) {
        return await this.SoapRequestWithBody('getMediaURI', input);
    }
    async Search(input) {
        return await this.SoapRequestWithBody('search', input).then((resp) => this.PostProcessMediaResult(resp));
    }
    PostProcessMediaResult(input) {
        const result = {
            index: input.index,
            count: input.count,
            total: input.total,
            mediaMetadata: undefined,
            mediaCollection: undefined,
        };
        if (input.mediaMetadata !== undefined) {
            result.mediaMetadata = array_helper_1.default.ForceArray(input.mediaMetadata);
            result.mediaMetadata = result.mediaMetadata.map((m) => {
                const withTrack = m;
                if (m.itemType === 'stream')
                    withTrack.trackUri = `x-sonosapi-stream:${m.id}?sid=${this.options.serviceId}`;
                return withTrack;
            });
        }
        if (input.mediaCollection !== undefined) {
            result.mediaCollection = array_helper_1.default.ForceArray(input.mediaCollection);
        }
        return result;
    }
    // #region Private server stuff
    async SoapRequest(action, isRetryWithNewCredentials = false) {
        this.debug('%s()', action);
        try {
            return await this.handleRequestAndParseResponse(this.generateRequest(action, undefined), action);
        }
        catch (err) {
            if (err instanceof smapi_error_1.default && err.Fault.faultstring === SmapiClientErrors.TokenRefreshRequiredError && !isRetryWithNewCredentials) {
                return await this.SoapRequest(action, true);
            }
            throw err;
        }
    }
    async SoapRequestWithBody(action, body, isRetryWithNewCredentials = false) {
        this.debug('%s(%o)', action, body);
        try {
            return await this.handleRequestAndParseResponse(this.generateRequest(action, body), action);
        }
        catch (err) {
            if (err instanceof smapi_error_1.default && err.Fault.faultstring === SmapiClientErrors.TokenRefreshRequiredError && !isRetryWithNewCredentials) {
                return await this.SoapRequestWithBody(action, body, true);
            }
            throw err;
        }
    }
    async handleRequestAndParseResponse(request, action, isRetryWithNewCredentials = false) {
        var _a, _b, _c, _d, _e;
        const response = await node_fetch_1.default(request);
        // if (!response.ok) {
        //   this.debug('handleRequest error %d %s', response.status, response.statusText);
        //   throw new Error(`Http status ${response.status} (${response.statusText})`);
        // }
        const result = fast_xml_parser_1.parse(await response.text(), { ignoreNameSpace: true });
        if (!result || !result.Envelope || !result.Envelope.Body) {
            this.debug('Invalid response for %s %o', action, result);
            throw new Error(`Invalid response for ${action}: ${result}`);
        }
        if (typeof result.Envelope.Body.Fault !== 'undefined') {
            const fault = result.Envelope.Body.Fault;
            if (!isRetryWithNewCredentials && fault.faultstring === 'tokenRefreshRequired') {
                this.debug('Saving new tokens');
                // Set new tokens, maybe result in event?
                this.authToken = (_b = (_a = fault.detail) === null || _a === void 0 ? void 0 : _a.refreshAuthTokenResult) === null || _b === void 0 ? void 0 : _b.authToken;
                this.key = (_d = (_c = fault.detail) === null || _c === void 0 ? void 0 : _c.refreshAuthTokenResult) === null || _d === void 0 ? void 0 : _d.privateKey;
                // this.debug('New authToken: %s', this.authToken);
                // this.debug('New private key: %s', this.key);
                if (this.options.saveNewAccount !== undefined && this.key && this.authToken) {
                    await this.options.saveNewAccount(this.options.serviceId, this.key, this.authToken);
                }
            }
            this.debug('Soap error %s %o', action, fault);
            throw new smapi_error_1.default(this.options.name, action, fault);
        }
        this.debug('handleRequest success');
        const body = result.Envelope.Body[`${action}Response`];
        return (_e = body[`${action}Result`]) !== null && _e !== void 0 ? _e : body;
    }
    messageAction(action) {
        return `"http://www.sonos.com/Services/1.1#${action}"`;
    }
    generateRequest(action, body) {
        return new node_fetch_1.Request(this.options.url, {
            method: 'POST',
            headers: {
                SOAPAction: this.messageAction(action),
                'Content-type': 'text/xml; charset=utf-8',
                'Accept-Language': 'en-US',
                'Accept-Encoding': 'gzip, deflate',
                'User-Agent': 'Linux UPnP/1.0 Sonos/29.3-87071 (ICRU_iPhone7,1); iOS/Version 8.2 (Build 12D508)',
            },
            body: this.generateRequestBody(action, body),
        });
    }
    generateRequestBody(action, body) {
        const soapHeader = this.generateSoapHeader();
        const soapBody = this.generateSoapBody(action, body);
        return this.generateSoapEnvelope([soapHeader, soapBody]);
    }
    generateSoapBody(action, body) {
        let messageBody = `<soap:Body>\r\n<s:${action}>`;
        if (body) {
            Object.entries(body).forEach((v) => {
                // Deconstruct v into key and value.
                const [key, value] = v;
                if (typeof value === 'boolean')
                    messageBody += `<s:${key}>${value === true ? '1' : '0'}</s:${key}>`;
                else
                    messageBody += `<s:${key}>${value}</s:${key}>`;
            });
        }
        messageBody += `</s:${action}>\r\n</soap:Body>`;
        return messageBody;
    }
    getHouseholdIdOrThrow() {
        if (this.options.householdId === undefined) {
            throw new Error('options.householdId is undefined, fetch from DevicePropertiesService.GetHouseholdID');
        }
        return this.options.householdId;
    }
    generateCredentialHeader(options = {}) {
        var _a, _b;
        let header = '  <s:credentials>\r\n';
        if (options.deviceId !== undefined) {
            header += `    <s:deviceId>${options.deviceId}</s:deviceId>\r\n`;
        }
        if (options.deviceCert !== undefined) {
            header += `    <s:deviceCert>${options.deviceCert}</s:deviceCert>\r\n`;
        }
        if (options.zonePlayerId !== undefined) {
            header += `    <s:zonePlayerId>${options.zonePlayerId}</s:zonePlayerId>\r\n`;
        }
        header += '    <s:deviceProvider>Sonos</s:deviceProvider>\r\n';
        // if (options.loginToken !== undefined) {
        if (this.options.auth === 'DeviceLink' || this.options.auth === 'AppLink') {
            header += `    <s:loginToken>
      <s:token>${(_a = this.authToken) !== null && _a !== void 0 ? _a : ''}</s:token>
      <s:key>${(_b = this.key) !== null && _b !== void 0 ? _b : ''}</s:key>
      <s:householdId>${this.getHouseholdIdOrThrow()}</s:householdId>
    </s:loginToken>\r\n`;
        }
        header += '  </s:credentials>';
        return header;
    }
    generateContextHeader(timezone) {
        return `  <s:context>
      <s:timeZone>${timezone}</s:timeZone>
    </s:context>`;
        //       <contentFiltering><explicit>${filterExplicit}</explicit></contentFiltering>
    }
    generateSoapHeader() {
        let header = '<soap:Header>\r\n';
        header += `${this.generateContextHeader(this.options.timezone || '+01:00')}\r\n`;
        header += this.generateCredentialHeader({ deviceId: this.options.deviceId });
        header += '</soap:Header>';
        return header;
    }
    generateSoapEnvelope(content) {
        let body = '<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:s="http://www.sonos.com/Services/1.1">\r\n';
        content.forEach((c) => {
            body += `${c}\r\n`;
        });
        body += '</soap:Envelope>';
        // this.debug('Soap envelop\r\n%s', body);
        return body;
    }
}
exports.SmapiClient = SmapiClient;
//# sourceMappingURL=smapi-client.js.map