"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZoneGroupTopologyService = void 0;
const array_helper_1 = __importDefault(require("../helpers/array-helper"));
const xml_helper_1 = __importDefault(require("../helpers/xml-helper"));
const zone_group_topology_service_1 = require("./zone-group-topology.service");
/**
 * Zone config stuff, eg getting all the configured sonos zones.
 *
 * @export
 * @class ZoneGroupTopologyService
 * @extends {ZoneGroupTopologyServiceBase}
 */
class ZoneGroupTopologyService extends zone_group_topology_service_1.ZoneGroupTopologyServiceBase {
    /**
     * Get all the sonos groups in your current network. Parsed the GetZoneGroupState output.
     *
     * @returns {Promise<ZoneGroup[]>}
     * @memberof ZoneGroupTopologyService
     */
    async GetParsedZoneGroupState() {
        const groupStateResponse = await this.GetZoneGroupState();
        if (typeof groupStateResponse.ZoneGroupState === 'string') {
            const decodedGroupState = xml_helper_1.default.DecodeAndParseXml(groupStateResponse.ZoneGroupState, '');
            const groups = array_helper_1.default.ForceArray(decodedGroupState.ZoneGroupState.ZoneGroups.ZoneGroup);
            return groups.map((g) => ZoneGroupTopologyService.ParseGroup(g));
        }
        // This should never happen, because it always is a string.
        /* istanbul ignore next */
        return groupStateResponse.ZoneGroupState;
    }
    static ParseChannelMapSet(channelMapSet) {
        if (typeof channelMapSet !== 'string' || channelMapSet === '') {
            return undefined;
        }
        const channels = channelMapSet.split(';');
        return channels.map((channel) => {
            const [uuid, channelId] = channel.split(',');
            return {
                uuid: uuid.split(':')[0],
                channelId,
            };
        }).reduce((previousChannels, channel) => (Object.assign(Object.assign({}, previousChannels), { [channel.channelId]: channel.uuid })), {});
    }
    static ParseMember(member) {
        const uri = new URL(member.Location);
        return {
            name: member.ZoneName,
            uuid: member.UUID,
            host: uri.hostname,
            port: parseInt(uri.port, 10),
            ChannelMapSet: ZoneGroupTopologyService.ParseChannelMapSet(member.ChannelMapSet),
            Icon: member.Icon,
            // This code looks strange, but have a look at https://github.com/svrooij/node-sonos-ts/issues/125
            MicEnabled: member.MicEnabled === 1 || member.MicEnabled === '1',
            Invisible: member.Invisible === 1 || member.Invisible === '1',
            SoftwareVersion: member.SoftwareVersion,
            SwGen: member.SWGen,
            HasConfiguredSSID: member.HasConfiguredSSID === '1' || member.HasConfiguredSSID === 1,
            WifiEnabled: member.WifiEnabled === '1' || member.WifiEnabled === 1,
            TVConfigurationError: parseInt(member.TVConfigurationError, 10),
            HdmiCecAvailable: member.HdmiCecAvailable === '1' || member.HdmiCecAvailable === 1,
        };
    }
    static ParseGroup(group) {
        const members = array_helper_1.default.ForceArray(group.ZoneGroupMember).map((m) => ZoneGroupTopologyService.ParseMember(m));
        const coordinator = members.find((m) => m.uuid === group.Coordinator);
        if (coordinator === undefined)
            throw new Error('Error parsing ZoneGroup');
        let { name } = coordinator;
        if (members.length > 1)
            name += ` + ${members.length - 1}`;
        return {
            groupId: group.ID,
            name,
            coordinator,
            members,
        };
    }
    ResolveEventPropertyValue(name, originalValue, type) {
        const parsedValue = super.ResolveEventPropertyValue(name, originalValue, type);
        if (name === 'ZoneGroupState') {
            const groups = array_helper_1.default.ForceArray(parsedValue.ZoneGroupState.ZoneGroups.ZoneGroup);
            return groups.map((g) => ZoneGroupTopologyService.ParseGroup(g));
        }
        return parsedValue;
    }
}
exports.ZoneGroupTopologyService = ZoneGroupTopologyService;
//# sourceMappingURL=zone-group-topology.service.extension.js.map