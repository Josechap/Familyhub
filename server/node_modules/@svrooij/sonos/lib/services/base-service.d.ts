import { Debugger } from 'debug';
import TypedEmitter from 'typed-emitter';
import { Track } from '../models/track';
import { ServiceEvent } from '../models/service-event';
import { SonosUpnpError } from '../models/sonos-upnp-error';
/**
 * Base Service class will handle all the requests to the sonos device.
 *
 * @description BaseService is used by all automatically generated services.
 * @export
 * @abstract
 * @class BaseService
 */
export default abstract class BaseService<TServiceEvent> {
    private uuid;
    protected readonly host: string;
    protected readonly port: number;
    private debugger?;
    private resolvedIp?;
    protected get debug(): Debugger;
    private events?;
    /**
     * Control URL is the relative endpoint to send command to.
     *
     * @abstract
     * @type {string}
     * @memberof BaseService
     */
    abstract readonly controlUrl: string;
    /**
     * Event Subscription Url is the relative endpoint to enable notifications.
     *
     * @abstract
     * @type {string}
     * @memberof BaseService
     */
    abstract readonly eventSubUrl: string;
    /**
     * Scp Url is the relative endpoint where this service is described
     *
     * @abstract
     * @type {string}
     * @memberof BaseService
     */
    abstract readonly scpUrl: string;
    /**
     * Service Name is the name of the service, used in the commands
     *
     * @abstract
     * @type {string}
     * @memberof BaseService
     */
    abstract readonly serviceNane: string;
    /**
     * Possible errors for this service
     *
     * @abstract
     * @type {SonosUpnpError[]}
     * @memberof BaseService
     */
    abstract readonly errors: SonosUpnpError[];
    /**
     * Creates an instance of the implemented service.
     * @param {string} host The ip (or hostname) of the sonos speaker
     * @param {number} [port=1400] The port of the sonos speaker (defaults to 1400)
     * @param {string} [uuid=Guid.create().toString()] The uuid of the speaker, used for grouping and events.
     * @memberof BaseService
     */
    constructor(host: string, port?: number, uuid?: string);
    get Host(): string;
    get Uuid(): string;
    private ResolveHostname;
    /**
     * SoapRequest will do a request that expects a Response
     *
     * @protected
     * @template TResponse
     * @param {string} action The action to call
     * @returns {Promise<TResponse>} Will return a promise of the requested response
     * @memberof BaseService
     */
    protected SoapRequest<TResponse>(action: string): Promise<TResponse>;
    /**
     * SoapRequestWithBody will do a request that expects a Response
     *
     * @protected
     * @template TRequest
     * @template TResponse
     * @param {string} action The action to call
     * @param {TBody} body The request body parameters
     * @returns {Promise<TResponse>}
     * @memberof BaseService
     */
    protected SoapRequestWithBody<TBody, TResponse>(action: string, body: TBody): Promise<TResponse>;
    /**
     * SoapRequestNoResponse will do a request where it doesn't expect a Response
     *
     * @protected
     * @param {string} action The action to call
     * @returns {Promise<boolean>} boolean returns true if command is send succesfull and sonos responded with ok
     * @memberof BaseService
     */
    protected SoapRequestNoResponse(action: string): Promise<boolean>;
    /**
     * SoapRequestWithBodyNoResponse will do a request where it doesn't expect a Response
     *
     * @protected
     * @template TBody
     * @param {string} action The action to call
     * @param {TBody} body The request body parameters
     * @returns {Promise<boolean>} boolean returns true if command is send succesfull and sonos responded with ok
     * @memberof BaseService
     */
    protected SoapRequestWithBodyNoResponse<TBody>(action: string, body: TBody): Promise<boolean>;
    private getUrl;
    private messageAction;
    private generateRequest;
    /**
     * generateRequestBody will generate the request body, and to conversion from 'Track' to xml if needed
     *
     * @private
     * @template TBody
     * @param {string} action
     * @param {TBody} body
     * @returns {string}
     * @memberof BaseService
     */
    private generateRequestBody;
    /**
     * handleRequest send the request to the device.
     *
     * @private
     * @param {Request} request the request to send
     * @returns {Promise<boolean>} boolean returns true if command is send succesfull and sonos responded with ok
     * @memberof BaseService
     */
    private handleRequest;
    /**
     * handleRequestAndParseResponse send the request to the device and parsed the result to the specified return type
     *
     * @private
     * @template TResponse
     * @param {Request} request the request to send
     * @param {string} action the action (used to parse the response)
     * @returns {Promise<TResponse>} a promise with the requested result
     * @memberof BaseService
     */
    private handleRequestAndParseResponse;
    /**
     * This method will handle the error responses, it will always throw an error, after debug output.
     *
     * @private
     * @template TResponse
     * @param {Response} response
     * @returns {Promise<TResponse>}
     * @memberof BaseService
     */
    private handleErrorResponse;
    protected abstract responseProperties(): {
        [key: string]: string;
    };
    /**
     * parseEmbeddedXml will parse the value of some response properties
     *
     * @private
     * @template TResponse
     * @param {*} input The object with properties that have XML
     * @returns {TResponse}
     * @memberof BaseService
     */
    private parseEmbeddedXml;
    protected parseValue(name: string, input: unknown, expectedType: string): Track | string | boolean | number | unknown;
    private sid?;
    private eventRenewInterval?;
    /**
     * Events allowes you access to the events generated by this service.
     *
     * @description The service will automatically subscribe to events when you first use this.
     * @readonly
     * @type {EventEmitter}
     * @memberof BaseService
     */
    get Events(): TypedEmitter<ServiceEvent<TServiceEvent>>;
    private emitEventsError;
    /**
     * Subscribe to events of this service, is called automatically.
     *
     * @private
     * @remarks Do not call manually!!
     */
    private subscribeForEvents;
    /**
     * Renew event subscription, is called automatically.
     *
     * @private
     * @remarks Do not call manually!!
     */
    private renewEventSubscription;
    /**
     * Unsubscribe to events of this service, is called automatically.
     *
     * @private
     * @remarks Do not call manually!!
     */
    private cancelSubscription;
    /**
     * Force refresh the event subscription
     *
     * @returns {Promise<boolean>} returns true on success and false if you weren't listening for events.
     * @memberof BaseService
     */
    CheckEventListener(): Promise<boolean>;
    /**
     * Parse Event called by the SonosEventListener, it will parse the xml and emit the right events
     *
     * @param {string} xml Event request body, received from the SonosEventListener
     * @memberof BaseService
     * @remarks Should not be called by anything other then SonosEventListener.
     */
    ParseEvent(xml: string): void;
    protected ResolveEventPropertyValue(name: string, originalValue: unknown, type: string): unknown;
    protected abstract eventProperties(): {
        [key: string]: string;
    };
    private cleanEventLastChange;
    private cleanEventBody;
}
//# sourceMappingURL=base-service.d.ts.map