/**
 * Sonos AVTransport service
 *
 * Stephan van Rooij
 * https://svrooij.io
 *
 * This file is generated, do not edit manually. https://svrooij.io/sonos-api-docs
 */
import BaseService from './base-service';
import { SonosUpnpError } from '../models/sonos-upnp-error';
import { PlayMode, Track } from '../models';
/**
 * Service that controls stuff related to transport (play/pause/next/special urls)
 *
 * @export
 * @class AVTransportService
 * @extends {BaseService}
 */
export declare class AVTransportService extends BaseService<AVTransportServiceEvent> {
    readonly serviceNane: string;
    readonly controlUrl: string;
    readonly eventSubUrl: string;
    readonly scpUrl: string;
    /**
     * Default errors and service specific errors
     *
     * @type {SonosUpnpError[]}
     * @remarks See https://svrooij.io/sonos-api-docs/#manual-documentation-file
     */
    readonly errors: SonosUpnpError[];
    AddMultipleURIsToQueue(input: {
        InstanceID: number;
        UpdateID: number;
        NumberOfURIs: number;
        EnqueuedURIs: string;
        EnqueuedURIsMetaData: Track | string;
        ContainerURI: string;
        ContainerMetaData: Track | string;
        DesiredFirstTrackNumberEnqueued: number;
        EnqueueAsNext: boolean;
    }): Promise<AddMultipleURIsToQueueResponse>;
    /**
     * Adds songs to the SONOS queue
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.EnqueuedURI
     * @param {Track | string} input.EnqueuedURIMetaData
     * @param {number} input.DesiredFirstTrackNumberEnqueued - use `0` to add at the end or `1` to insert at the beginning
     * @param {boolean} input.EnqueueAsNext
     * @remarks In NORMAL play mode the songs are added prior to the specified `DesiredFirstTrackNumberEnqueued`.
     */
    AddURIToQueue(input: {
        InstanceID: number;
        EnqueuedURI: string;
        EnqueuedURIMetaData: Track | string;
        DesiredFirstTrackNumberEnqueued: number;
        EnqueueAsNext: boolean;
    }): Promise<AddURIToQueueResponse>;
    AddURIToSavedQueue(input: {
        InstanceID: number;
        ObjectID: string;
        UpdateID: number;
        EnqueuedURI: string;
        EnqueuedURIMetaData: Track | string;
        AddAtIndex: number;
    }): Promise<AddURIToSavedQueueResponse>;
    BackupQueue(input?: {
        InstanceID: number;
    }): Promise<boolean>;
    /**
     * Leave the current group and revert to a single player.
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     */
    BecomeCoordinatorOfStandaloneGroup(input?: {
        InstanceID: number;
    }): Promise<BecomeCoordinatorOfStandaloneGroupResponse>;
    BecomeGroupCoordinator(input: {
        InstanceID: number;
        CurrentCoordinator: string;
        CurrentGroupID: string;
        OtherMembers: string;
        TransportSettings: string;
        CurrentURI: string;
        CurrentURIMetaData: Track | string;
        SleepTimerState: string;
        AlarmState: string;
        StreamRestartState: string;
        CurrentQueueTrackList: string;
        CurrentVLIState: string;
    }): Promise<boolean>;
    BecomeGroupCoordinatorAndSource(input: {
        InstanceID: number;
        CurrentCoordinator: string;
        CurrentGroupID: string;
        OtherMembers: string;
        CurrentURI: string;
        CurrentURIMetaData: Track | string;
        SleepTimerState: string;
        AlarmState: string;
        StreamRestartState: string;
        CurrentAVTTrackList: string;
        CurrentQueueTrackList: string;
        CurrentSourceState: string;
        ResumePlayback: boolean;
    }): Promise<boolean>;
    ChangeCoordinator(input: {
        InstanceID: number;
        CurrentCoordinator: string;
        NewCoordinator: string;
        NewTransportSettings: string;
        CurrentAVTransportURI: string;
    }): Promise<boolean>;
    ChangeTransportSettings(input: {
        InstanceID: number;
        NewTransportSettings: string;
        CurrentAVTransportURI: string;
    }): Promise<boolean>;
    /**
     * Stop playing after set sleep timer or cancel
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.NewSleepTimerDuration - Time to stop after, as `hh:mm:ss` or empty string to cancel
     * @remarks Send to non-coordinator returns error code 800
     */
    ConfigureSleepTimer(input: {
        InstanceID: number;
        NewSleepTimerDuration: string;
    }): Promise<boolean>;
    CreateSavedQueue(input: {
        InstanceID: number;
        Title: string;
        EnqueuedURI: string;
        EnqueuedURIMetaData: Track | string;
    }): Promise<CreateSavedQueueResponse>;
    /**
     * Delegates the coordinator role to another player in the same group
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.NewCoordinator - uuid of the new coordinator - must be in same group
     * @param {boolean} input.RejoinGroup - Should former coordinator rejoin the group?
     * @remarks Send to non-coordinator has no results - should be avoided.
     */
    DelegateGroupCoordinationTo(input: {
        InstanceID: number;
        NewCoordinator: string;
        RejoinGroup: boolean;
    }): Promise<boolean>;
    EndDirectControlSession(input?: {
        InstanceID: number;
    }): Promise<boolean>;
    /**
     * Get crossfade mode
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Send to non-coordinator may return wrong value as only the coordinator value in a group
     */
    GetCrossfadeMode(input?: {
        InstanceID: number;
    }): Promise<GetCrossfadeModeResponse>;
    /**
     * Get current transport actions such as Set, Stop, Pause, Play, X_DLNA_SeekTime, Next, X_DLNA_SeekTrackNr
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Send to non-coordinator returns only `Start` and `Stop` since it cannot control the stream.
     */
    GetCurrentTransportActions(input?: {
        InstanceID: number;
    }): Promise<GetCurrentTransportActionsResponse>;
    GetDeviceCapabilities(input?: {
        InstanceID: number;
    }): Promise<GetDeviceCapabilitiesResponse>;
    /**
     * Get information about the current playing media (queue)
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     */
    GetMediaInfo(input?: {
        InstanceID: number;
    }): Promise<GetMediaInfoResponse>;
    /**
     * Get information about current position (position in queue and time in current song)
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     */
    GetPositionInfo(input?: {
        InstanceID: number;
    }): Promise<GetPositionInfoResponse>;
    /**
     * Get time left on sleeptimer.
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Send to non-coordinator returns error code 800
     */
    GetRemainingSleepTimerDuration(input?: {
        InstanceID: number;
    }): Promise<GetRemainingSleepTimerDurationResponse>;
    GetRunningAlarmProperties(input?: {
        InstanceID: number;
    }): Promise<GetRunningAlarmPropertiesResponse>;
    /**
     * Get current transport status, speed and state such as PLAYING, STOPPED, PLAYING, PAUSED_PLAYBACK, TRANSITIONING, NO_MEDIA_PRESENT
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Send to non-coordinator always returns PLAYING
     */
    GetTransportInfo(input?: {
        InstanceID: number;
    }): Promise<GetTransportInfoResponse>;
    /**
     * Get transport settings
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Send to non-coordinator returns the settings of it's queue
     */
    GetTransportSettings(input?: {
        InstanceID: number;
    }): Promise<GetTransportSettingsResponse>;
    /**
     * Go to next song
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Possibly not supported at the moment see GetCurrentTransportActions
     */
    Next(input?: {
        InstanceID: number;
    }): Promise<boolean>;
    NotifyDeletedURI(input: {
        InstanceID: number;
        DeletedURI: string;
    }): Promise<boolean>;
    /**
     * Pause playback
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     */
    Pause(input?: {
        InstanceID: number;
    }): Promise<boolean>;
    /**
     * Start playing the set TransportURI
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.Speed - Play speed usually 1, can be a fraction of 1 [ '1' ]
     */
    Play(input: {
        InstanceID: number;
        Speed: string;
    }): Promise<boolean>;
    /**
     * Go to previous song
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Possibly not supported at the moment see GetCurrentTransportActions
     */
    Previous(input?: {
        InstanceID: number;
    }): Promise<boolean>;
    /**
     * Flushes the SONOS queue.
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks If queue is already empty it throw error 804. Send to non-coordinator returns error code 800.
     */
    RemoveAllTracksFromQueue(input?: {
        InstanceID: number;
    }): Promise<boolean>;
    RemoveTrackFromQueue(input: {
        InstanceID: number;
        ObjectID: string;
        UpdateID: number;
    }): Promise<boolean>;
    /**
     * Removes the specified range of songs from the SONOS queue.
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {number} input.UpdateID - Leave blank
     * @param {number} input.StartingIndex - between 1 and queue-length
     * @param {number} input.NumberOfTracks
     */
    RemoveTrackRangeFromQueue(input: {
        InstanceID: number;
        UpdateID: number;
        StartingIndex: number;
        NumberOfTracks: number;
    }): Promise<RemoveTrackRangeFromQueueResponse>;
    ReorderTracksInQueue(input: {
        InstanceID: number;
        StartingIndex: number;
        NumberOfTracks: number;
        InsertBefore: number;
        UpdateID: number;
    }): Promise<boolean>;
    ReorderTracksInSavedQueue(input: {
        InstanceID: number;
        ObjectID: string;
        UpdateID: number;
        TrackList: string;
        NewPositionList: string;
    }): Promise<ReorderTracksInSavedQueueResponse>;
    RunAlarm(input: {
        InstanceID: number;
        AlarmID: number;
        LoggedStartTime: string;
        Duration: string;
        ProgramURI: string;
        ProgramMetaData: Track | string;
        PlayMode: PlayMode;
        Volume: number;
        IncludeLinkedZones: boolean;
    }): Promise<boolean>;
    /**
     * Saves the current SONOS queue as a SONOS playlist and outputs objectID
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.Title - SONOS playlist title
     * @param {string} input.ObjectID - Leave blank
     * @remarks Send to non-coordinator returns error code 800
     */
    SaveQueue(input: {
        InstanceID: number;
        Title: string;
        ObjectID: string;
    }): Promise<SaveQueueResponse>;
    /**
     * Seek track in queue, time delta or absolute time in song
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.Unit - What to seek [ 'TRACK_NR' / 'REL_TIME' / 'TIME_DELTA' ]
     * @param {string} input.Target - Position of track in queue (start at 1) or `hh:mm:ss` for `REL_TIME` or `+/-hh:mm:ss` for `TIME_DELTA`
     * @remarks Returns error code 701 in case that content does not support Seek or send to non-coordinator
     */
    Seek(input: {
        InstanceID: number;
        Unit: string;
        Target: string;
    }): Promise<boolean>;
    /**
     * Set the transport URI to a song, a stream, the queue, another player-rincon and a lot more
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.CurrentURI - The new TransportURI - its a special SONOS format
     * @param {Track | string} input.CurrentURIMetaData - Track Metadata, see MetadataHelper.GuessTrack to guess based on track uri
     * @remarks If set to another player RINCON, the player is grouped with that one.
     */
    SetAVTransportURI(input: {
        InstanceID: number;
        CurrentURI: string;
        CurrentURIMetaData: Track | string;
    }): Promise<boolean>;
    /**
     * Set crossfade mode
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {boolean} input.CrossfadeMode
     * @remarks Send to non-coordinator returns error code 800. Same for content, which does not support crossfade mode.
     */
    SetCrossfadeMode(input: {
        InstanceID: number;
        CrossfadeMode: boolean;
    }): Promise<boolean>;
    SetNextAVTransportURI(input: {
        InstanceID: number;
        NextURI: string;
        NextURIMetaData: Track | string;
    }): Promise<boolean>;
    /**
     * Set the PlayMode
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {PlayMode} input.NewPlayMode - New playmode [ 'NORMAL' / 'REPEAT_ALL' / 'REPEAT_ONE' / 'SHUFFLE_NOREPEAT' / 'SHUFFLE' / 'SHUFFLE_REPEAT_ONE' ]
     * @remarks Send to non-coordinator returns error code 712. If SONOS queue is not activated returns error code 712.
     */
    SetPlayMode(input: {
        InstanceID: number;
        NewPlayMode: PlayMode;
    }): Promise<boolean>;
    /**
     * Snooze the current alarm for some time.
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.Duration - Snooze time as `hh:mm:ss`, 10 minutes = 00:10:00
     */
    SnoozeAlarm(input: {
        InstanceID: number;
        Duration: string;
    }): Promise<boolean>;
    StartAutoplay(input: {
        InstanceID: number;
        ProgramURI: string;
        ProgramMetaData: Track | string;
        Volume: number;
        IncludeLinkedZones: boolean;
        ResetVolumeAfter: boolean;
    }): Promise<boolean>;
    /**
     * Stop playback
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     */
    Stop(input?: {
        InstanceID: number;
    }): Promise<boolean>;
    protected responseProperties(): {
        [key: string]: string;
    };
    protected eventProperties(): {
        [key: string]: string;
    };
}
export interface AddMultipleURIsToQueueResponse {
    FirstTrackNumberEnqueued: number;
    NumTracksAdded: number;
    NewQueueLength: number;
    NewUpdateID: number;
}
export interface AddURIToQueueResponse {
    FirstTrackNumberEnqueued: number;
    NumTracksAdded: number;
    NewQueueLength: number;
}
export interface AddURIToSavedQueueResponse {
    NumTracksAdded: number;
    NewQueueLength: number;
    NewUpdateID: number;
}
export interface BecomeCoordinatorOfStandaloneGroupResponse {
    DelegatedGroupCoordinatorID: string;
    NewGroupID: string;
}
export interface CreateSavedQueueResponse {
    NumTracksAdded: number;
    NewQueueLength: number;
    AssignedObjectID: string;
    NewUpdateID: number;
}
export interface GetCrossfadeModeResponse {
    CrossfadeMode: boolean;
}
export interface GetCurrentTransportActionsResponse {
    Actions: string;
}
export interface GetDeviceCapabilitiesResponse {
    PlayMedia: string;
    RecMedia: string;
    RecQualityModes: string;
}
export interface GetMediaInfoResponse {
    NrTracks: number;
    MediaDuration: string;
    CurrentURI: string;
    CurrentURIMetaData: Track | string;
    NextURI: string;
    NextURIMetaData: Track | string;
    PlayMedium: string;
    RecordMedium: string;
    WriteStatus: string;
}
export interface GetPositionInfoResponse {
    Track: number;
    TrackDuration: string;
    TrackMetaData: Track | string;
    TrackURI: string;
    RelTime: string;
    AbsTime: string;
    RelCount: number;
    AbsCount: number;
}
export interface GetRemainingSleepTimerDurationResponse {
    RemainingSleepTimerDuration: string;
    CurrentSleepTimerGeneration: number;
}
export interface GetRunningAlarmPropertiesResponse {
    AlarmID: number;
    GroupID: string;
    LoggedStartTime: string;
}
export interface GetTransportInfoResponse {
    CurrentTransportState: string;
    CurrentTransportStatus: string;
    CurrentSpeed: string;
}
export interface GetTransportSettingsResponse {
    PlayMode: PlayMode;
    RecQualityMode: string;
}
export interface RemoveTrackRangeFromQueueResponse {
    NewUpdateID: number;
}
export interface ReorderTracksInSavedQueueResponse {
    QueueLengthChange: number;
    NewQueueLength: number;
    NewUpdateID: number;
}
export interface SaveQueueResponse {
    AssignedObjectID: string;
}
export interface AVTransportServiceEvent {
    AbsoluteCounterPosition?: number;
    AbsoluteTimePosition?: string;
    AlarmIDRunning?: number;
    AlarmLoggedStartTime?: string;
    AlarmRunning?: boolean;
    AVTransportURI?: string;
    AVTransportURIMetaData?: Track | string;
    CurrentCrossfadeMode?: boolean;
    CurrentMediaDuration?: string;
    CurrentPlayMode?: PlayMode;
    CurrentRecordQualityMode?: string;
    CurrentSection?: number;
    CurrentTrack?: number;
    CurrentTrackDuration?: string;
    CurrentTrackMetaData?: Track | string;
    CurrentTrackURI?: string;
    CurrentTransportActions?: string;
    CurrentValidPlayModes?: string;
    DirectControlAccountID?: string;
    DirectControlClientID?: string;
    DirectControlIsSuspended?: boolean;
    EnqueuedTransportURI?: string;
    EnqueuedTransportURIMetaData?: Track | string;
    LastChange?: string;
    MuseSessions?: string;
    NextAVTransportURI?: string;
    NextAVTransportURIMetaData?: Track | string;
    NextTrackMetaData?: Track | string;
    NextTrackURI?: string;
    NumberOfTracks?: number;
    PlaybackStorageMedium?: string;
    PossiblePlaybackStorageMedia?: string;
    PossibleRecordQualityModes?: string;
    PossibleRecordStorageMedia?: string;
    QueueUpdateID?: number;
    RecordMediumWriteStatus?: string;
    RecordStorageMedium?: string;
    RelativeCounterPosition?: number;
    RelativeTimePosition?: string;
    RestartPending?: boolean;
    SleepTimerGeneration?: number;
    SnoozeRunning?: boolean;
    TransportErrorDescription?: string;
    TransportErrorHttpCode?: string;
    TransportErrorHttpHeaders?: string;
    TransportErrorURI?: string;
    TransportPlaySpeed?: string;
    TransportState?: string;
    TransportStatus?: string;
}
//# sourceMappingURL=av-transport.service.d.ts.map