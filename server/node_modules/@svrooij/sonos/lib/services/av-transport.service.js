"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AVTransportService = void 0;
/**
 * Sonos AVTransport service
 *
 * Stephan van Rooij
 * https://svrooij.io
 *
 * This file is generated, do not edit manually. https://svrooij.io/sonos-api-docs
 */
const base_service_1 = __importDefault(require("./base-service"));
const sonos_upnp_errors_1 = __importDefault(require("./sonos-upnp-errors"));
/**
 * Service that controls stuff related to transport (play/pause/next/special urls)
 *
 * @export
 * @class AVTransportService
 * @extends {BaseService}
 */
class AVTransportService extends base_service_1.default {
    constructor() {
        super(...arguments);
        this.serviceNane = 'AVTransport';
        this.controlUrl = '/MediaRenderer/AVTransport/Control';
        this.eventSubUrl = '/MediaRenderer/AVTransport/Event';
        this.scpUrl = '/xml/AVTransport1.xml';
        /**
         * Default errors and service specific errors
         *
         * @type {SonosUpnpError[]}
         * @remarks See https://svrooij.io/sonos-api-docs/#manual-documentation-file
         */
        this.errors = [
            ...sonos_upnp_errors_1.default.defaultErrors,
            { code: 701, description: 'Transition not available' },
            { code: 702, description: 'No content' },
            { code: 703, description: 'Read error' },
            { code: 704, description: 'Format not supported for playback' },
            { code: 705, description: 'Transport is locked' },
            { code: 706, description: 'Write error' },
            { code: 707, description: 'Media protected or not writeable' },
            { code: 708, description: 'Format not supported for recording' },
            { code: 709, description: 'Media is full' },
            { code: 710, description: 'Seek mode not supported' },
            { code: 711, description: 'Illegal seek target' },
            { code: 712, description: 'Play mode not supported' },
            { code: 713, description: 'Record quality not supported' },
            { code: 714, description: 'Illegal MIME-Type' },
            { code: 715, description: 'Content busy' },
            { code: 716, description: 'Resource not found' },
            { code: 717, description: 'Play speed not supported' },
            { code: 718, description: 'Invalid InstanceID' },
            { code: 737, description: 'No dns configured' },
            { code: 738, description: 'Bad domain' },
            { code: 739, description: 'Server error' },
            { code: 800, description: 'Command not supported or not a coordinator' },
        ];
    }
    // #region actions
    async AddMultipleURIsToQueue(input) { return await this.SoapRequestWithBody('AddMultipleURIsToQueue', input); }
    /**
     * Adds songs to the SONOS queue
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.EnqueuedURI
     * @param {Track | string} input.EnqueuedURIMetaData
     * @param {number} input.DesiredFirstTrackNumberEnqueued - use `0` to add at the end or `1` to insert at the beginning
     * @param {boolean} input.EnqueueAsNext
     * @remarks In NORMAL play mode the songs are added prior to the specified `DesiredFirstTrackNumberEnqueued`.
     */
    async AddURIToQueue(input) { return await this.SoapRequestWithBody('AddURIToQueue', input); }
    async AddURIToSavedQueue(input) { return await this.SoapRequestWithBody('AddURIToSavedQueue', input); }
    async BackupQueue(input = { InstanceID: 0 }) { return await this.SoapRequestWithBodyNoResponse('BackupQueue', input); }
    /**
     * Leave the current group and revert to a single player.
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     */
    async BecomeCoordinatorOfStandaloneGroup(input = { InstanceID: 0 }) { return await this.SoapRequestWithBody('BecomeCoordinatorOfStandaloneGroup', input); }
    async BecomeGroupCoordinator(input) { return await this.SoapRequestWithBodyNoResponse('BecomeGroupCoordinator', input); }
    async BecomeGroupCoordinatorAndSource(input) { return await this.SoapRequestWithBodyNoResponse('BecomeGroupCoordinatorAndSource', input); }
    async ChangeCoordinator(input) { return await this.SoapRequestWithBodyNoResponse('ChangeCoordinator', input); }
    async ChangeTransportSettings(input) { return await this.SoapRequestWithBodyNoResponse('ChangeTransportSettings', input); }
    /**
     * Stop playing after set sleep timer or cancel
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.NewSleepTimerDuration - Time to stop after, as `hh:mm:ss` or empty string to cancel
     * @remarks Send to non-coordinator returns error code 800
     */
    async ConfigureSleepTimer(input) { return await this.SoapRequestWithBodyNoResponse('ConfigureSleepTimer', input); }
    async CreateSavedQueue(input) { return await this.SoapRequestWithBody('CreateSavedQueue', input); }
    /**
     * Delegates the coordinator role to another player in the same group
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.NewCoordinator - uuid of the new coordinator - must be in same group
     * @param {boolean} input.RejoinGroup - Should former coordinator rejoin the group?
     * @remarks Send to non-coordinator has no results - should be avoided.
     */
    async DelegateGroupCoordinationTo(input) { return await this.SoapRequestWithBodyNoResponse('DelegateGroupCoordinationTo', input); }
    async EndDirectControlSession(input = { InstanceID: 0 }) { return await this.SoapRequestWithBodyNoResponse('EndDirectControlSession', input); }
    /**
     * Get crossfade mode
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Send to non-coordinator may return wrong value as only the coordinator value in a group
     */
    async GetCrossfadeMode(input = { InstanceID: 0 }) { return await this.SoapRequestWithBody('GetCrossfadeMode', input); }
    /**
     * Get current transport actions such as Set, Stop, Pause, Play, X_DLNA_SeekTime, Next, X_DLNA_SeekTrackNr
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Send to non-coordinator returns only `Start` and `Stop` since it cannot control the stream.
     */
    async GetCurrentTransportActions(input = { InstanceID: 0 }) { return await this.SoapRequestWithBody('GetCurrentTransportActions', input); }
    async GetDeviceCapabilities(input = { InstanceID: 0 }) { return await this.SoapRequestWithBody('GetDeviceCapabilities', input); }
    /**
     * Get information about the current playing media (queue)
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     */
    async GetMediaInfo(input = { InstanceID: 0 }) { return await this.SoapRequestWithBody('GetMediaInfo', input); }
    /**
     * Get information about current position (position in queue and time in current song)
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     */
    async GetPositionInfo(input = { InstanceID: 0 }) { return await this.SoapRequestWithBody('GetPositionInfo', input); }
    /**
     * Get time left on sleeptimer.
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Send to non-coordinator returns error code 800
     */
    async GetRemainingSleepTimerDuration(input = { InstanceID: 0 }) { return await this.SoapRequestWithBody('GetRemainingSleepTimerDuration', input); }
    async GetRunningAlarmProperties(input = { InstanceID: 0 }) { return await this.SoapRequestWithBody('GetRunningAlarmProperties', input); }
    /**
     * Get current transport status, speed and state such as PLAYING, STOPPED, PLAYING, PAUSED_PLAYBACK, TRANSITIONING, NO_MEDIA_PRESENT
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Send to non-coordinator always returns PLAYING
     */
    async GetTransportInfo(input = { InstanceID: 0 }) { return await this.SoapRequestWithBody('GetTransportInfo', input); }
    /**
     * Get transport settings
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Send to non-coordinator returns the settings of it's queue
     */
    async GetTransportSettings(input = { InstanceID: 0 }) { return await this.SoapRequestWithBody('GetTransportSettings', input); }
    /**
     * Go to next song
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Possibly not supported at the moment see GetCurrentTransportActions
     */
    async Next(input = { InstanceID: 0 }) { return await this.SoapRequestWithBodyNoResponse('Next', input); }
    async NotifyDeletedURI(input) { return await this.SoapRequestWithBodyNoResponse('NotifyDeletedURI', input); }
    /**
     * Pause playback
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     */
    async Pause(input = { InstanceID: 0 }) { return await this.SoapRequestWithBodyNoResponse('Pause', input); }
    /**
     * Start playing the set TransportURI
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.Speed - Play speed usually 1, can be a fraction of 1 [ '1' ]
     */
    async Play(input) { return await this.SoapRequestWithBodyNoResponse('Play', input); }
    /**
     * Go to previous song
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks Possibly not supported at the moment see GetCurrentTransportActions
     */
    async Previous(input = { InstanceID: 0 }) { return await this.SoapRequestWithBodyNoResponse('Previous', input); }
    /**
     * Flushes the SONOS queue.
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @remarks If queue is already empty it throw error 804. Send to non-coordinator returns error code 800.
     */
    async RemoveAllTracksFromQueue(input = { InstanceID: 0 }) { return await this.SoapRequestWithBodyNoResponse('RemoveAllTracksFromQueue', input); }
    async RemoveTrackFromQueue(input) { return await this.SoapRequestWithBodyNoResponse('RemoveTrackFromQueue', input); }
    /**
     * Removes the specified range of songs from the SONOS queue.
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {number} input.UpdateID - Leave blank
     * @param {number} input.StartingIndex - between 1 and queue-length
     * @param {number} input.NumberOfTracks
     */
    async RemoveTrackRangeFromQueue(input) { return await this.SoapRequestWithBody('RemoveTrackRangeFromQueue', input); }
    async ReorderTracksInQueue(input) { return await this.SoapRequestWithBodyNoResponse('ReorderTracksInQueue', input); }
    async ReorderTracksInSavedQueue(input) { return await this.SoapRequestWithBody('ReorderTracksInSavedQueue', input); }
    async RunAlarm(input) { return await this.SoapRequestWithBodyNoResponse('RunAlarm', input); }
    /**
     * Saves the current SONOS queue as a SONOS playlist and outputs objectID
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.Title - SONOS playlist title
     * @param {string} input.ObjectID - Leave blank
     * @remarks Send to non-coordinator returns error code 800
     */
    async SaveQueue(input) { return await this.SoapRequestWithBody('SaveQueue', input); }
    /**
     * Seek track in queue, time delta or absolute time in song
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.Unit - What to seek [ 'TRACK_NR' / 'REL_TIME' / 'TIME_DELTA' ]
     * @param {string} input.Target - Position of track in queue (start at 1) or `hh:mm:ss` for `REL_TIME` or `+/-hh:mm:ss` for `TIME_DELTA`
     * @remarks Returns error code 701 in case that content does not support Seek or send to non-coordinator
     */
    async Seek(input) { return await this.SoapRequestWithBodyNoResponse('Seek', input); }
    /**
     * Set the transport URI to a song, a stream, the queue, another player-rincon and a lot more
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.CurrentURI - The new TransportURI - its a special SONOS format
     * @param {Track | string} input.CurrentURIMetaData - Track Metadata, see MetadataHelper.GuessTrack to guess based on track uri
     * @remarks If set to another player RINCON, the player is grouped with that one.
     */
    async SetAVTransportURI(input) { return await this.SoapRequestWithBodyNoResponse('SetAVTransportURI', input); }
    /**
     * Set crossfade mode
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {boolean} input.CrossfadeMode
     * @remarks Send to non-coordinator returns error code 800. Same for content, which does not support crossfade mode.
     */
    async SetCrossfadeMode(input) { return await this.SoapRequestWithBodyNoResponse('SetCrossfadeMode', input); }
    async SetNextAVTransportURI(input) { return await this.SoapRequestWithBodyNoResponse('SetNextAVTransportURI', input); }
    /**
     * Set the PlayMode
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {PlayMode} input.NewPlayMode - New playmode [ 'NORMAL' / 'REPEAT_ALL' / 'REPEAT_ONE' / 'SHUFFLE_NOREPEAT' / 'SHUFFLE' / 'SHUFFLE_REPEAT_ONE' ]
     * @remarks Send to non-coordinator returns error code 712. If SONOS queue is not activated returns error code 712.
     */
    async SetPlayMode(input) { return await this.SoapRequestWithBodyNoResponse('SetPlayMode', input); }
    /**
     * Snooze the current alarm for some time.
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     * @param {string} input.Duration - Snooze time as `hh:mm:ss`, 10 minutes = 00:10:00
     */
    async SnoozeAlarm(input) { return await this.SoapRequestWithBodyNoResponse('SnoozeAlarm', input); }
    async StartAutoplay(input) { return await this.SoapRequestWithBodyNoResponse('StartAutoplay', input); }
    /**
     * Stop playback
     *
     * @param {number} input.InstanceID - InstanceID should always be `0`
     */
    async Stop(input = { InstanceID: 0 }) { return await this.SoapRequestWithBodyNoResponse('Stop', input); }
    // #endregion
    responseProperties() {
        return {
            FirstTrackNumberEnqueued: 'number',
            NumTracksAdded: 'number',
            NewQueueLength: 'number',
            NewUpdateID: 'number',
            DelegatedGroupCoordinatorID: 'string',
            NewGroupID: 'string',
            AssignedObjectID: 'string',
            CrossfadeMode: 'boolean',
            Actions: 'string',
            PlayMedia: 'string',
            RecMedia: 'string',
            RecQualityModes: 'string',
            NrTracks: 'number',
            MediaDuration: 'string',
            CurrentURI: 'string',
            CurrentURIMetaData: 'Track | string',
            NextURI: 'string',
            NextURIMetaData: 'Track | string',
            PlayMedium: 'string',
            RecordMedium: 'string',
            WriteStatus: 'string',
            Track: 'number',
            TrackDuration: 'string',
            TrackMetaData: 'Track | string',
            TrackURI: 'string',
            RelTime: 'string',
            AbsTime: 'string',
            RelCount: 'number',
            AbsCount: 'number',
            RemainingSleepTimerDuration: 'string',
            CurrentSleepTimerGeneration: 'number',
            AlarmID: 'number',
            GroupID: 'string',
            LoggedStartTime: 'string',
            CurrentTransportState: 'string',
            CurrentTransportStatus: 'string',
            CurrentSpeed: 'string',
            PlayMode: 'PlayMode',
            RecQualityMode: 'string',
            QueueLengthChange: 'number',
        };
    }
    // Event properties from service description.
    eventProperties() {
        return {
            AbsoluteCounterPosition: 'number',
            AbsoluteTimePosition: 'string',
            AlarmIDRunning: 'number',
            AlarmLoggedStartTime: 'string',
            AlarmRunning: 'boolean',
            AVTransportURI: 'string',
            AVTransportURIMetaData: 'Track | string',
            CurrentCrossfadeMode: 'boolean',
            CurrentMediaDuration: 'string',
            CurrentPlayMode: 'PlayMode',
            CurrentRecordQualityMode: 'string',
            CurrentSection: 'number',
            CurrentTrack: 'number',
            CurrentTrackDuration: 'string',
            CurrentTrackMetaData: 'Track | string',
            CurrentTrackURI: 'string',
            CurrentTransportActions: 'string',
            CurrentValidPlayModes: 'string',
            DirectControlAccountID: 'string',
            DirectControlClientID: 'string',
            DirectControlIsSuspended: 'boolean',
            EnqueuedTransportURI: 'string',
            EnqueuedTransportURIMetaData: 'Track | string',
            LastChange: 'string',
            MuseSessions: 'string',
            NextAVTransportURI: 'string',
            NextAVTransportURIMetaData: 'Track | string',
            NextTrackMetaData: 'Track | string',
            NextTrackURI: 'string',
            NumberOfTracks: 'number',
            PlaybackStorageMedium: 'string',
            PossiblePlaybackStorageMedia: 'string',
            PossibleRecordQualityModes: 'string',
            PossibleRecordStorageMedia: 'string',
            QueueUpdateID: 'number',
            RecordMediumWriteStatus: 'string',
            RecordStorageMedium: 'string',
            RelativeCounterPosition: 'number',
            RelativeTimePosition: 'string',
            RestartPending: 'boolean',
            SleepTimerGeneration: 'number',
            SnoozeRunning: 'boolean',
            TransportErrorDescription: 'string',
            TransportErrorHttpCode: 'string',
            TransportErrorHttpHeaders: 'string',
            TransportErrorURI: 'string',
            TransportPlaySpeed: 'string',
            TransportState: 'string',
            TransportStatus: 'string',
        };
    }
}
exports.AVTransportService = AVTransportService;
//# sourceMappingURL=av-transport.service.js.map