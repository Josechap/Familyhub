"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = __importStar(require("node-fetch"));
const fast_xml_parser_1 = require("fast-xml-parser");
const guid_typescript_1 = require("guid-typescript");
const events_1 = require("events");
const debug_1 = __importDefault(require("debug"));
const ip_helper_1 = __importDefault(require("../helpers/ip-helper"));
const soap_helper_1 = __importDefault(require("../helpers/soap-helper"));
const xml_helper_1 = __importDefault(require("../helpers/xml-helper"));
const metadata_helper_1 = __importDefault(require("../helpers/metadata-helper"));
const sonos_event_listener_1 = __importDefault(require("../sonos-event-listener"));
const service_event_1 = require("../models/service-event");
const event_errors_1 = require("../models/event-errors");
const sonos_error_1 = __importDefault(require("../models/sonos-error"));
const http_error_1 = __importDefault(require("../models/http-error"));
/**
 * Base Service class will handle all the requests to the sonos device.
 *
 * @description BaseService is used by all automatically generated services.
 * @export
 * @abstract
 * @class BaseService
 */
class BaseService {
    /**
     * Creates an instance of the implemented service.
     * @param {string} host The ip (or hostname) of the sonos speaker
     * @param {number} [port=1400] The port of the sonos speaker (defaults to 1400)
     * @param {string} [uuid=Guid.create().toString()] The uuid of the speaker, used for grouping and events.
     * @memberof BaseService
     */
    constructor(host, port = 1400, uuid = guid_typescript_1.Guid.create().toString()) {
        this.uuid = uuid;
        this.host = host;
        this.port = port;
    }
    get debug() {
        if (this.debugger === undefined)
            this.debugger = debug_1.default(`sonos:service:${this.serviceNane.toLowerCase()}:${this.host}`);
        return this.debugger;
    }
    get Host() {
        return this.host;
    }
    get Uuid() {
        return this.uuid;
    }
    async ResolveHostname() {
        if (this.resolvedIp === undefined) {
            this.resolvedIp = ip_helper_1.default.IsIpv4(this.host) ? this.host : await ip_helper_1.default.ResolveHostname(this.host);
        }
    }
    // #region Protected requests handlers
    /**
     * SoapRequest will do a request that expects a Response
     *
     * @protected
     * @template TResponse
     * @param {string} action The action to call
     * @returns {Promise<TResponse>} Will return a promise of the requested response
     * @memberof BaseService
     */
    async SoapRequest(action) {
        this.debug('%s()', action);
        await this.ResolveHostname();
        return await this.handleRequestAndParseResponse(this.generateRequest(action, undefined), action);
    }
    /**
     * SoapRequestWithBody will do a request that expects a Response
     *
     * @protected
     * @template TRequest
     * @template TResponse
     * @param {string} action The action to call
     * @param {TBody} body The request body parameters
     * @returns {Promise<TResponse>}
     * @memberof BaseService
     */
    async SoapRequestWithBody(action, body) {
        this.debug('%s(%o)', action, body);
        await this.ResolveHostname();
        return await this.handleRequestAndParseResponse(this.generateRequest(action, body), action);
    }
    /**
     * SoapRequestNoResponse will do a request where it doesn't expect a Response
     *
     * @protected
     * @param {string} action The action to call
     * @returns {Promise<boolean>} boolean returns true if command is send succesfull and sonos responded with ok
     * @memberof BaseService
     */
    async SoapRequestNoResponse(action) {
        this.debug('%s()', action);
        await this.ResolveHostname();
        return await this.handleRequest(this.generateRequest(action, undefined), action);
    }
    /**
     * SoapRequestWithBodyNoResponse will do a request where it doesn't expect a Response
     *
     * @protected
     * @template TBody
     * @param {string} action The action to call
     * @param {TBody} body The request body parameters
     * @returns {Promise<boolean>} boolean returns true if command is send succesfull and sonos responded with ok
     * @memberof BaseService
     */
    async SoapRequestWithBodyNoResponse(action, body) {
        this.debug('%s(%o)', action, body);
        await this.ResolveHostname();
        return await this.handleRequest(this.generateRequest(action, body), action);
    }
    // #endregion
    // #region Request builders
    getUrl() {
        var _a;
        return `http://${(_a = this.resolvedIp) !== null && _a !== void 0 ? _a : this.host}:${this.port}${this.controlUrl}`;
    }
    messageAction(action) {
        return `"urn:schemas-upnp-org:service:${this.serviceNane}:1#${action}"`;
    }
    generateRequest(action, body) {
        return new node_fetch_1.Request(this.getUrl(), {
            method: 'POST',
            headers: {
                SOAPAction: this.messageAction(action),
                'Content-type': 'text/xml; charset=utf8',
            },
            body: this.generateRequestBody(action, body),
            timeout: 30000,
        });
    }
    /**
     * generateRequestBody will generate the request body, and to conversion from 'Track' to xml if needed
     *
     * @private
     * @template TBody
     * @param {string} action
     * @param {TBody} body
     * @returns {string}
     * @memberof BaseService
     */
    generateRequestBody(action, body) {
        let messageBody = `<u:${action} xmlns:u="urn:schemas-upnp-org:service:${this.serviceNane}:1">`;
        if (body) {
            Object.entries(body).forEach((v) => {
                // Deconstruct v into key and value.
                const [key, value] = v;
                if (typeof value === 'object' && key.indexOf('MetaData') > -1)
                    messageBody += `<${key}>${xml_helper_1.default.EncodeXml(metadata_helper_1.default.TrackToMetaData(value))}</${key}>`;
                else if (typeof value === 'string' && key.endsWith('URI'))
                    messageBody += `<${key}>${xml_helper_1.default.EncodeTrackUri(value)}</${key}>`;
                else if (typeof value === 'boolean')
                    messageBody += `<${key}>${value === true ? '1' : '0'}</${key}>`;
                else
                    messageBody += `<${key}>${value !== null && value !== void 0 ? value : ''}</${key}>`;
            });
        }
        messageBody += `</u:${action}>`;
        return soap_helper_1.default.PutInEnvelope(messageBody);
    }
    // #endregion
    // #region Request handlers
    /**
     * handleRequest send the request to the device.
     *
     * @private
     * @param {Request} request the request to send
     * @returns {Promise<boolean>} boolean returns true if command is send succesfull and sonos responded with ok
     * @memberof BaseService
     */
    async handleRequest(request, action) {
        const response = await node_fetch_1.default(request);
        if (response.ok) {
            return true;
        }
        return await this.handleErrorResponse(action, response);
    }
    /**
     * handleRequestAndParseResponse send the request to the device and parsed the result to the specified return type
     *
     * @private
     * @template TResponse
     * @param {Request} request the request to send
     * @param {string} action the action (used to parse the response)
     * @returns {Promise<TResponse>} a promise with the requested result
     * @memberof BaseService
     */
    async handleRequestAndParseResponse(request, action) {
        const response = await node_fetch_1.default(request);
        const responseText = response.ok === true
            ? await response.text()
            : await this.handleErrorResponse(action, response);
        const result = fast_xml_parser_1.parse(responseText);
        if (!result || !result['s:Envelope']) {
            this.debug('Invalid response for %s %o', action, result);
            throw new Error(`Invalid response for ${action}: ${result}`);
        }
        return this.parseEmbeddedXml(result['s:Envelope']['s:Body'][`u:${action}Response`]);
    }
    /**
     * This method will handle the error responses, it will always throw an error, after debug output.
     *
     * @private
     * @template TResponse
     * @param {Response} response
     * @returns {Promise<TResponse>}
     * @memberof BaseService
     */
    async handleErrorResponse(action, response) {
        var _a, _b;
        const responseText = await response.text();
        if (responseText !== '') {
            const errorResponse = fast_xml_parser_1.parse(responseText);
            if (typeof errorResponse['s:Envelope']['s:Body']['s:Fault'] !== 'undefined') {
                const error = errorResponse['s:Envelope']['s:Body']['s:Fault'];
                this.debug('Sonos error on %s %o', action, error);
                const upnpErrorCode = (_b = (_a = error.detail) === null || _a === void 0 ? void 0 : _a.UPnPError) === null || _b === void 0 ? void 0 : _b.errorCode;
                const upnpError = upnpErrorCode !== undefined ? this.errors.find((e) => e.code === upnpErrorCode) : undefined;
                throw new sonos_error_1.default(action, error.faultcode, error.faultstring, upnpErrorCode, upnpError === null || upnpError === void 0 ? void 0 : upnpError.description);
            }
        }
        this.debug('handleRequest error %d %s', response.status, response.statusText);
        throw new http_error_1.default(action, response.status, response.statusText);
    }
    /**
     * parseEmbeddedXml will parse the value of some response properties
     *
     * @private
     * @template TResponse
     * @param {*} input The object with properties that have XML
     * @returns {TResponse}
     * @memberof BaseService
     */
    parseEmbeddedXml(input) {
        const output = {};
        const keys = Object.keys(input);
        keys.forEach((k) => {
            output[k] = this.parseValue(k, input[k], this.responseProperties()[k]);
        });
        return output;
    }
    parseValue(name, input, expectedType) {
        if (expectedType === 'Track | string' && typeof input === 'string') {
            if (input.startsWith('&lt;')) {
                return metadata_helper_1.default.ParseDIDLTrack(xml_helper_1.default.DecodeAndParseXml(input), this.host, this.port);
            }
            return undefined; // undefined is more appropriate, but that would be a breaking change.
        }
        if (name.indexOf('URI') > -1 && typeof input === 'string') {
            return input === '' ? undefined : xml_helper_1.default.DecodeTrackUri(input);
        }
        switch (expectedType) {
            case 'boolean':
                return input === 1 || input === '1';
            case 'number':
                return typeof input === 'number' ? input : parseInt(input, 10);
            case 'string':
                return typeof input === 'string' && input === '' ? undefined : input;
            default:
                return input;
        }
    }
    /**
     * Events allowes you access to the events generated by this service.
     *
     * @description The service will automatically subscribe to events when you first use this.
     * @readonly
     * @type {EventEmitter}
     * @memberof BaseService
     */
    get Events() {
        if (this.events === undefined) {
            this.events = new events_1.EventEmitter();
            this.events.on('removeListener', async (eventName) => {
                var _a;
                this.debug('Listener removed for %s', eventName);
                const events = (_a = this.events) === null || _a === void 0 ? void 0 : _a.eventNames().filter((e) => e !== 'removeListener' && e !== 'newListener' && e !== service_event_1.ServiceEvents.SubscriptionError);
                if (this.sid !== undefined && (events === null || events === void 0 ? void 0 : events.length) === 0) {
                    await this.cancelSubscription()
                        .catch((err) => {
                        this.debug('Cancelling event subscription failed', err);
                        this.emitEventsError(new event_errors_1.EventsError(event_errors_1.EventsErrorCode.UnsubscribeFailed, err));
                    });
                }
            });
            this.events.on('newListener', async (eventName) => {
                if (eventName === service_event_1.ServiceEvents.SubscriptionError)
                    return;
                this.debug('Listener added for %s  (sid: \'%s\', SONOS_DISABLE_EVENTS: %o)', eventName, this.sid, (typeof process.env.SONOS_DISABLE_EVENTS === 'undefined'));
                if (this.sid === undefined && process.env.SONOS_DISABLE_EVENTS === undefined) {
                    this.debug('Subscribing to events');
                    await this.subscribeForEvents()
                        .catch((err) => {
                        this.debug('Subscriping for events failed', err);
                        this.emitEventsError(new event_errors_1.EventsError(event_errors_1.EventsErrorCode.SubscribeFailed, err));
                    });
                }
            });
        }
        return this.events;
    }
    emitEventsError(err) {
        if (this.events !== undefined) {
            this.events.emit(service_event_1.ServiceEvents.SubscriptionError, err);
        }
    }
    /**
     * Subscribe to events of this service, is called automatically.
     *
     * @private
     * @remarks Do not call manually!!
     */
    async subscribeForEvents() {
        var _a;
        const callback = sonos_event_listener_1.default.DefaultInstance.GetEndpoint(this.uuid, this.serviceNane);
        this.debug('Creating event subscription with callback: %s', callback);
        await this.ResolveHostname();
        const resp = await node_fetch_1.default(new node_fetch_1.Request(`http://${(_a = this.resolvedIp) !== null && _a !== void 0 ? _a : this.host}:${this.port}${this.eventSubUrl}`, {
            method: 'SUBSCRIBE',
            headers: {
                callback: `<${callback}>`,
                NT: 'upnp:event',
                Timeout: 'Second-3600',
            },
            timeout: 15000,
        }));
        const sid = resp.ok ? resp.headers.get('sid') : undefined;
        if (sid === undefined || sid === '') {
            throw new Error('No subscription id received');
        }
        this.sid = sid;
        if (this.eventRenewInterval === undefined) {
            this.eventRenewInterval = setInterval(async () => {
                await this.renewEventSubscription()
                    .catch((err) => {
                    this.debug('Renewing event subscription failed', err);
                    this.emitEventsError(new event_errors_1.EventsError(event_errors_1.EventsErrorCode.RenewSubscriptionFailed, err));
                });
            }, 600 * 1000); // Renew events every 10 minutes.
        }
        sonos_event_listener_1.default.DefaultInstance.RegisterSubscription(sid, this);
        return true;
    }
    /**
     * Renew event subscription, is called automatically.
     *
     * @private
     * @remarks Do not call manually!!
     */
    async renewEventSubscription() {
        var _a;
        this.debug('Renewing event subscription');
        await this.ResolveHostname();
        if (typeof this.sid === 'string' && this.sid !== '') {
            const resp = await node_fetch_1.default(new node_fetch_1.Request(`http://${(_a = this.resolvedIp) !== null && _a !== void 0 ? _a : this.host}:${this.port}${this.eventSubUrl}`, {
                method: 'SUBSCRIBE',
                headers: {
                    SID: this.sid,
                    Timeout: 'Second-3600',
                },
                timeout: 15000,
            }));
            if (resp.ok) {
                this.debug('Renewed event subscription');
                return true;
            }
        }
        this.debug('Renew event subscription failed, trying to resubscribe');
        await this.subscribeForEvents();
        return this.sid !== undefined;
    }
    /**
     * Unsubscribe to events of this service, is called automatically.
     *
     * @private
     * @remarks Do not call manually!!
     */
    async cancelSubscription() {
        var _a;
        this.debug('Cancelling event subscription');
        if (this.eventRenewInterval !== undefined) {
            clearInterval(this.eventRenewInterval);
        }
        if (this.sid !== undefined) {
            const resp = await node_fetch_1.default(new node_fetch_1.Request(`http://${(_a = this.resolvedIp) !== null && _a !== void 0 ? _a : this.host}:${this.port}${this.eventSubUrl}`, {
                method: 'UNSUBSCRIBE',
                headers: {
                    SID: this.sid,
                },
                timeout: 15000,
            }));
            sonos_event_listener_1.default.DefaultInstance.UnregisterSubscription(this.sid);
            this.sid = undefined;
            this.debug('Cancelled event subscription success %o', resp.ok);
            return resp.ok;
        }
        this.debug('No subscription to cancel');
        return false;
    }
    /**
     * Force refresh the event subscription
     *
     * @returns {Promise<boolean>} returns true on success and false if you weren't listening for events.
     * @memberof BaseService
     */
    async CheckEventListener() {
        if (this.sid !== undefined) {
            return await this.renewEventSubscription();
        }
        return false;
    }
    /**
     * Parse Event called by the SonosEventListener, it will parse the xml and emit the right events
     *
     * @param {string} xml Event request body, received from the SonosEventListener
     * @memberof BaseService
     * @remarks Should not be called by anything other then SonosEventListener.
     */
    ParseEvent(xml) {
        this.debug('Got event');
        const rawBody = fast_xml_parser_1.parse(xml, { attributeNamePrefix: '', ignoreNameSpace: true }).propertyset.property;
        this.Events.emit(service_event_1.ServiceEvents.Unprocessed, rawBody);
        if (rawBody.LastChange) {
            const rawEventWrapper = xml_helper_1.default.DecodeAndParseXmlNoNS(rawBody.LastChange, '');
            const rawEvent = rawEventWrapper.Event.InstanceID ? rawEventWrapper.Event.InstanceID : rawEventWrapper.Event;
            const parsedEvent = this.cleanEventLastChange(rawEvent);
            // console.log(rawEvent)
            this.Events.emit(service_event_1.ServiceEvents.ServiceEvent, parsedEvent);
        }
        else {
            const properties = Array.isArray(rawBody) ? rawBody : [rawBody];
            try {
                const parsedEvent = this.cleanEventBody(properties);
                this.Events.emit(service_event_1.ServiceEvents.ServiceEvent, parsedEvent);
            }
            catch (e) {
                this.debug('Error %o', e);
            }
        }
    }
    ResolveEventPropertyValue(name, originalValue, type) {
        if (typeof originalValue === 'string' && originalValue.startsWith('&lt;')) {
            if (name.endsWith('MetaData')) {
                return metadata_helper_1.default.ParseDIDLTrack(xml_helper_1.default.DecodeAndParseXml(originalValue), this.host, this.port);
            }
            return xml_helper_1.default.DecodeAndParseXml(originalValue, '');
        }
        switch (type) {
            case 'number':
                return typeof originalValue === 'number' ? originalValue : parseInt(originalValue, 10);
            case 'boolean':
                return originalValue === '1' || originalValue === 1;
            default:
                return originalValue;
        }
    }
    cleanEventLastChange(inputRaw) {
        const input = Array.isArray(inputRaw) ? inputRaw[0] : inputRaw;
        const output = {};
        const inKeys = Object.keys(input).filter((k) => k !== 'val');
        const properties = this.eventProperties();
        const keys = Object.keys(properties).filter((k) => inKeys.indexOf(k) > -1);
        keys.forEach((k) => {
            var _a;
            const originalValue = (_a = input[k].val) !== null && _a !== void 0 ? _a : input[k];
            if (originalValue === undefined || originalValue === '')
                return;
            output[k] = this.ResolveEventPropertyValue(k, originalValue, properties[k]);
        });
        if (Object.keys(output).length === 0) {
            const entries = Object.entries(input);
            if (entries.length === 1) {
                return this.cleanEventLastChange(entries[0][1]);
            }
        }
        return output;
    }
    cleanEventBody(input) {
        // const output: {[key: string]: any} = {};
        const temp = {};
        input.forEach((v) => {
            Object.keys(v)
                .forEach((k) => {
                temp[k] = v[k];
            });
        });
        return this.cleanEventLastChange(temp);
    }
}
exports.default = BaseService;
//# sourceMappingURL=base-service.js.map