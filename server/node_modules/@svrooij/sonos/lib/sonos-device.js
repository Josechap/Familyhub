"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const node_fetch_1 = __importDefault(require("node-fetch"));
const fast_xml_parser_1 = require("fast-xml-parser");
const sonos_device_base_1 = __importDefault(require("./sonos-device-base"));
const models_1 = require("./models");
const async_helper_1 = __importDefault(require("./helpers/async-helper"));
const metadata_helper_1 = __importDefault(require("./helpers/metadata-helper"));
const smapi_client_1 = require("./musicservices/smapi-client");
const ip_helper_1 = __importDefault(require("./helpers/ip-helper"));
const json_helper_1 = __importDefault(require("./helpers/json-helper"));
const tts_helper_1 = __importDefault(require("./helpers/tts-helper"));
const sonos_notification_two_1 = __importDefault(require("./sonos-notification-two"));
/**
 * Main class to control a single sonos device.
 *
 * @export
 * @class SonosDevice
 * @extends {SonosDeviceBase}
 */
class SonosDevice extends sonos_device_base_1.default {
    /**
     * Creates an instance of SonosDevice.
     * @param {string} host the ip or host of the speaker you want to add
     * @param {number} [port=1400] the port (is always 1400)
     * @param {(string | undefined)} [uuid=undefined] the uuid of the speaker, is set by the SonosManager. like RINCON_macaddres01400, used in some commands
     * @param {(string | undefined)} [name=undefined] the name of the speaker, is set by the SonosManager by default
     * @param {({coordinator?: SonosDevice; name: string; managerEvents: EventEmitter} | undefined)} [groupConfig=undefined] groupConfig is used by the SonosManager to setup group change events.
     * @memberof SonosDevice
     */
    constructor(host, port = 1400, uuid = undefined, name = undefined, groupConfig = undefined) {
        super(host, port, uuid);
        // Internal notification queue
        this.notifications = [];
        this.isSubscribed = false;
        this.boundHandleEventErrorEvent = this.handleEventErrorEvent.bind(this);
        this.boundHandleAvTransportEvent = this.handleAvTransportEvent.bind(this);
        this.boundHandleRenderingControlEvent = this.handleRenderingControlEvent.bind(this);
        this.boundHandleCoordinatorSimpleStateEvent = this.handleCoordinatorSimpleStateEvent.bind(this);
        // #endregion
        // #region Group stuff
        this.boundHandleGroupUpdate = this.handleGroupUpdate.bind(this);
        this.name = name;
        if (groupConfig) {
            this.groupName = groupConfig.name;
            if (groupConfig.coordinator !== undefined && uuid !== groupConfig.coordinator.uuid) {
                this.coordinator = groupConfig.coordinator;
                this.handleCoordinatorSimpleStateEvent(this.coordinator.currentTransportState === models_1.TransportState.Playing ? models_1.TransportState.Playing : models_1.TransportState.Stopped);
            }
            if (uuid) {
                groupConfig.managerEvents.on(uuid, this.boundHandleGroupUpdate);
            }
        }
        if (ip_helper_1.default.IsIpv4(this.host) === false) {
            this.debug('Sonos devices don\'t like hostnames, resolve once is faster IpHelper.ResolveHostname(host)');
        }
    }
    /**
     * Preload some device data, should be called before accessing most properties of this class.
     *
     * @returns {Promise<boolean>} Either returns true or throws an error
     * @memberof SonosDevice
     */
    async LoadDeviceData() {
        this.zoneAttributes = await this.GetZoneAttributes();
        this.name = this.zoneAttributes.CurrentZoneName;
        this.volume = (await this.RenderingControlService.GetVolume({ InstanceID: 0, Channel: 'Master' })).CurrentVolume;
        this.muted = (await this.RenderingControlService.GetMute({ InstanceID: 0, Channel: 'Master' })).CurrentMute;
        return true;
    }
    // #region Added functionality
    /**
     * Add One track to the queue
     *
     * @param {string} trackUri
     * @param {number} [positionInQueue=0]
     * @param {boolean} [enqueueAsNext=true]
     * @returns {Promise<AddURIToQueueResponse>}
     * @memberof SonosDevice
     */
    async AddUriToQueue(trackUri, positionInQueue = 0, enqueueAsNext = true) {
        const guessedMetaData = metadata_helper_1.default.GuessMetaDataAndTrackUri(trackUri);
        return await this.AVTransportService.AddURIToQueue({
            InstanceID: 0,
            EnqueuedURI: guessedMetaData.trackUri,
            EnqueuedURIMetaData: guessedMetaData.metadata,
            DesiredFirstTrackNumberEnqueued: positionInQueue,
            EnqueueAsNext: enqueueAsNext,
        });
    }
    /**
     * Get a parsed list of all alarms.
     *
     * @returns {Promise<Alarm[]>}
     * @deprecated Will be removed in favor of Extended AlarmClockService
     * @memberof SonosDevice
     */
    async AlarmList() {
        return await this.AlarmClockService.ListAndParseAlarms();
    }
    /**
     * Patch a single alarm. Only the ID and one property you want to change are required.
     *
     * @param {PatchAlarm} [options]
     * @param {number} options.ID The ID of the alarm to update
     * @param {string | undefined} options.StartLocalTime The time the alarm has to start 'hh:mm:ss'
     * @param {string | undefined} options.Duration The duration of the alarm 'hh:mm:ss'
     * @param {string | undefined} options.Recurrence What should the recurrence be ['DAILY','ONCE','WEEKDAYS']
     * @param {boolean | undefined} options.Enabled Should this alarm be enabled
     * @param {PlayMode | undefined} options.PlayMode What playmode should be used
     * @param {number | undefined} options.Volume The requested alarm volume
     * @deprecated Will be removed in favor of Extended AlarmClockService
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async AlarmPatch(options) {
        return await this.AlarmClockService.PatchAlarm(options);
    }
    /**
     * Execute any sonos command by name, see examples/commands.js
     *
     * @param {string} command Command you wish to execute, like 'Play' or 'AVTransportService.Pause'. CASE SENSITIVE!!!
     * @param {(string | unknown | number | undefined)} options If the function requires options specify them here. A json string is automatically parsed to an object (if possible).
     * @returns {Promise<unknown>}
     * @memberof SonosDevice
     */
    ExecuteCommand(command, options) {
        let service = '';
        let correctCommand = command;
        if (command.indexOf('.') > -1) {
            const split = command.split('.', 2);
            [service, correctCommand] = split;
        }
        const foundService = this.GetServiceByName(service);
        const objectToCallOn = typeof foundService !== 'undefined'
            ? foundService
            : this.executeCommandGetFunctions();
        const proto = Object.getPrototypeOf(objectToCallOn);
        const propertyDescriptions = Object.getOwnPropertyDescriptors(proto);
        const baseProto = Object.getPrototypeOf(proto);
        const basePropertyDescriptions = Object.getOwnPropertyDescriptors(baseProto);
        const allKeys = [...Object.keys(propertyDescriptions), ...Object.keys(basePropertyDescriptions)];
        const functionToCall = allKeys.find((key) => key.toLowerCase() === correctCommand.toLowerCase());
        if (typeof functionToCall === 'string' && typeof (objectToCallOn[functionToCall]) === 'function') {
            if (options === undefined) {
                return objectToCallOn[functionToCall]();
            }
            if (typeof (options) === 'string') {
                const parsedOptions = json_helper_1.default.TryParse(options);
                return objectToCallOn[functionToCall](parsedOptions);
            }
            // number or object options;
            return objectToCallOn[functionToCall](options);
        }
        throw new Error(`Command ${correctCommand} isn't a function`);
    }
    executeCommandGetFunctions() {
        // This code looks weird, but is required to convince TypeScript this is actually what we want.
        return this;
    }
    /**
     * Get the device description
     *
     * @returns {Promise<DeviceDescription>}
     * @memberof SonosDevice
     */
    async GetDeviceDescription() {
        const resp = await node_fetch_1.default(`http://${this.Host}:${this.port}/xml/device_description.xml`)
            .then((response) => {
            if (response.ok) {
                return response.text();
            }
            throw new Error(`Loading device description failed ${response.status} ${response.statusText}`);
        });
        const { root: { device } } = fast_xml_parser_1.parse(resp);
        return {
            manufacturer: device.manufacturer,
            modelNumber: device.modelNumber,
            modelDescription: device.modelDescription,
            modelName: device.modelName,
            softwareVersion: device.softwareVersion,
            swGen: device.swGen,
            hardwareVersion: device.hardwareVersion,
            serialNumber: device.serialNum,
            udn: device.UDN,
            minCompatibleVersion: device.minCompatibleVersion,
            legacyCompatibleVersion: device.legacyCompatibleVersion,
            apiVersion: device.apiVersion,
            minApiVersion: device.minApiVersion,
            displayVersion: device.displayVersion,
            extraVersion: device.extraVersion,
            roomName: device.roomName,
            displayName: device.displayName,
            zoneType: device.zoneType,
            internalSpeakerSize: device.internalSpeakerSize,
            iconUrl: `http://${this.Host}:${this.port}${device.iconList.icon.url}`,
            feature1: device.feature1,
            feature2: device.feature2,
            feature3: device.feature3,
        };
    }
    /**
     * Get your favorite radio shows, just a browse shortcut.
     *
     * @returns {Promise<BrowseResponse>}
     * @memberof SonosDevice
     */
    async GetFavoriteRadioShows() {
        return await this.ContentDirectoryService.BrowseParsedWithDefaults('R:0/1');
    }
    /**
     * Get your favorite radio stations, just a browse shortcut.
     *
     * @returns {Promise<BrowseResponse>}
     * @memberof SonosDevice
     */
    async GetFavoriteRadioStations() {
        return await this.ContentDirectoryService.BrowseParsedWithDefaults('R:0/0');
    }
    /**
     * Get your favorite songs, just a browse shortcut.
     *
     * @returns {Promise<BrowseResponse>}
     * @memberof SonosDevice
     */
    async GetFavorites() {
        return await this.ContentDirectoryService.BrowseParsedWithDefaults('FV:2');
    }
    /**
     * Get the current queue, just a browse shortcut.
     *
     * @returns {Promise<BrowseResponse>}
     * @memberof SonosDevice
     */
    async GetQueue() {
        return await this.ContentDirectoryService.BrowseParsedWithDefaults('Q:0');
    }
    /**
     * Join this device to an other group, if you know the coordinator uuid you can do .AVTransportService.SetAVTransportURI({InstanceID: 0, CurrentURI: `x-rincon:${uuid}`, CurrentURIMetaData: ''})
     *
     * @param {string} otherDevice The name of the other device, (to find the needed coordinator uuid)
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async JoinGroup(otherDevice) {
        this.debug('JoinGroup(%s)', otherDevice);
        const zones = await this.ZoneGroupTopologyService.GetParsedZoneGroupState();
        const groupToJoin = zones.find((z) => z.members.some((m) => m.name.toLowerCase() === otherDevice.toLowerCase()));
        if (groupToJoin === undefined) {
            throw new Error(`Player '${otherDevice}' isn't found!`);
        }
        if (groupToJoin.members.some((m) => m.uuid === this.Uuid)) {
            return Promise.resolve(false); // Already in the group.
        }
        return await this.AVTransportService.SetAVTransportURI({ InstanceID: 0, CurrentURI: `x-rincon:${groupToJoin.coordinator.uuid}`, CurrentURIMetaData: '' });
    }
    async LoadUuid(force = false) {
        if (!this.uuid.startsWith('RINCON') || force) {
            const attributes = await this.DevicePropertiesService.GetZoneInfo();
            this.uuid = `RINCON_${attributes.MACAddress.replace(/:/g, '')}0${this.port}`;
        }
        return this.uuid;
    }
    /**
     * Create a client for a specific music service
     *
     * @param {number} id The id of the music service, see MusicServicesList
     * @param {string} options.key Cached authentication key
     * @param {string} options.authToken Cached authentication token
     * @returns {Promise<SmapiClient>}
     * @memberof SonosDevice
     */
    async MusicServicesClient(serviceId, options = {}) {
        var _a, _b;
        if (this.deviceId === undefined)
            this.deviceId = (await this.SystemPropertiesService.GetString({ VariableName: 'R_TrialZPSerial' })).StringValue;
        const services = await this.MusicServicesService.ListAndParseAvailableServices(true);
        if (services === undefined)
            throw new Error('Music list could not be loaded');
        const service = services.find((s) => s.Id === serviceId);
        if (service === undefined)
            throw new Error('MusicService could not be found');
        // if (service.Policy.Auth !== 'Anonymous') throw new Error('Music service requires authentication, which isn\'t supported (yet)');
        let accountData;
        if (service.Policy.Auth === 'AppLink' || service.Policy.Auth === 'DeviceLink') {
            accountData = await this.SystemPropertiesService.GetAccountData(serviceId);
        }
        return new smapi_client_1.SmapiClient({
            name: service.Name,
            auth: service.Policy.Auth,
            url: service.SecureUri || service.Uri,
            deviceId: this.deviceId,
            serviceId: service.Id,
            householdId: service.Policy.Auth === 'AppLink' || service.Policy.Auth === 'DeviceLink' ? (await this.DevicePropertiesService.GetHouseholdID()).CurrentHouseholdID : undefined,
            authToken: (_a = accountData === null || accountData === void 0 ? void 0 : accountData.AuthToken) !== null && _a !== void 0 ? _a : options.authToken,
            key: (_b = accountData === null || accountData === void 0 ? void 0 : accountData.Key) !== null && _b !== void 0 ? _b : options.key,
            saveNewAccount: async (serviceName, key, token) => {
                await this.SystemPropertiesService.SaveAccount(serviceName, key, token);
            },
        });
    }
    /**
     * Music services the user is logged-in to
     *
     * @returns {(Promise<Array<MusicService>>)}
     * @memberof SonosDevice
     */
    async MusicServicesSubscribed() {
        const ids = await this.SystemPropertiesService.SavedAccounts();
        if (ids === undefined || ids.length === 0) {
            return undefined;
        }
        const list = await this.MusicServicesService.ListAndParseAvailableServices(true);
        return list.filter((m) => ids.indexOf(m.Id) > -1);
    }
    /**
     * Get the state of the speaker, which can be reverted to with RestoreState
     */
    async GetState() {
        var _a;
        if (this.muted === undefined) {
            this.muted = (await this.RenderingControlService.GetMute({ InstanceID: 0, Channel: 'Master' })).CurrentMute;
        }
        if (this.volume === undefined) {
            this.volume = (await this.RenderingControlService.GetVolume({ InstanceID: 0, Channel: 'Master' })).CurrentVolume;
        }
        return {
            mediaInfo: await this.AVTransportService.GetMediaInfo(),
            muted: this.Muted === true,
            positionInfo: await this.AVTransportService.GetPositionInfo(),
            transportState: (_a = this.CurrentTransportStateSimple) !== null && _a !== void 0 ? _a : (await this.AVTransportService.GetTransportInfo()).CurrentTransportState,
            volume: this.volume,
        };
    }
    /**
     * Restore to the state from before, used internally by the notification system.
     *
     * @param state The state of the speaker from 'GetState()'
     * @param delayBetweenCommands Sonos speakers cannot process commands fast after each other. use 50ms - 800ms for best results
     */
    async RestoreState(state, delayBetweenCommands = undefined) {
        var _a;
        if (this.Volume !== state.volume) {
            await this.SetVolume(state.volume);
            if (delayBetweenCommands !== undefined)
                await async_helper_1.default.Delay(delayBetweenCommands);
        }
        if (this.Muted !== state.muted) {
            await this.RenderingControlService.SetMute({ InstanceID: 0, Channel: 'Master', DesiredMute: state.muted });
        }
        const isBroadcast = typeof state.mediaInfo.CurrentURIMetaData !== 'string' // Should not happen, is parsed in the service
            && ((_a = state.mediaInfo.CurrentURIMetaData) === null || _a === void 0 ? void 0 : _a.UpnpClass) === 'object.item.audioItem.audioBroadcast'; // This UpnpClass should for sure be skipped.
        await this.AVTransportService.SetAVTransportURI({ InstanceID: 0, CurrentURI: state.mediaInfo.CurrentURI, CurrentURIMetaData: state.mediaInfo.CurrentURIMetaData });
        if (delayBetweenCommands !== undefined)
            await async_helper_1.default.Delay(delayBetweenCommands);
        if (state.positionInfo.Track > 1 && state.mediaInfo.NrTracks > 1) {
            this.debug('Selecting track %d', state.positionInfo.Track);
            await this.SeekTrack(state.positionInfo.Track)
                .catch((err) => {
                this.debug('Error selecting track, happens with some music services %o', err);
            });
            if (delayBetweenCommands !== undefined)
                await async_helper_1.default.Delay(delayBetweenCommands);
        }
        if (state.positionInfo.RelTime && state.mediaInfo.MediaDuration !== '0:00:00' && !isBroadcast) {
            this.debug('Setting back time to %s', state.positionInfo.RelTime);
            await this.SeekPosition(state.positionInfo.RelTime)
                .catch((err) => {
                this.debug('Reverting back track time failed, happens for some music services (radio or stream). %o', err);
            });
            if (delayBetweenCommands !== undefined)
                await async_helper_1.default.Delay(delayBetweenCommands);
        }
        if (state.transportState === models_1.TransportState.Playing || state.transportState === models_1.TransportState.Transitioning) {
            await this.AVTransportService.Play({ InstanceID: 0, Speed: '1' });
        }
        return true;
    }
    /**
     * Play some url, and revert back to what was playing before. Very useful for playing a notification or TTS sound.
     *
     * @param {PlayNotificationOptions} options The options
     * @param {string} [options.trackUri] The uri of the sound to play as notification, can be every supported sonos uri.
     * @param {string|Track} [options.metadata] The metadata of the track to play, will be guesses if undefined.
     * @param {number} [options.delayMs] Delay in ms between commands, for better notification playback stability. Use 100 to 800 for best results
     * @param {callback} [options.notificationFired] Specify a callback that is called when this notification has played.
     * @param {boolean} [options.onlyWhenPlaying] Only play a notification if currently playing music. You don't have to check if the user is home ;)
     * @param {number} [options.timeout] Number of seconds the notification should play, as a fallback if the event doesn't come through.
     * @param {number} [options.volume] Change the volume for the notification and revert afterwards.
     * @returns {Promise<true>} Returns when added to queue or (for the first) when all notifications have played.
     * @remarks The first notification will return when all notifications have played, notifications send in between will return when added to the queue.
     * Use 'notificationFired' in the request if you want to know when your specific notification has played.
     * @memberof SonosDevice
     */
    async PlayNotification(options) {
        this.debug('PlayNotification(%o)', options);
        if (options.delayMs !== undefined && (options.delayMs < 1 || options.delayMs > 4000)) {
            throw new Error('Delay (if specified) should be between 1 and 4000');
        }
        if (options.volume !== undefined && (options.volume < 1 || options.volume > 100)) {
            throw new Error('Volume needs to be between 1 and 100');
        }
        const playingNotification = this.playingNotification === true;
        this.playingNotification = true;
        // Generate metadata if needed
        if (options.metadata === undefined) {
            const metaOptions = options;
            const guessedMetaData = metadata_helper_1.default.GuessMetaDataAndTrackUri(options.trackUri);
            metaOptions.metadata = guessedMetaData.metadata;
            metaOptions.trackUri = guessedMetaData.trackUri;
            this.notifications.push(metaOptions);
        }
        else {
            this.notifications.push(options);
        }
        if (playingNotification) {
            this.debug('Notification added to queue');
            return false;
        }
        const state = await this.GetState();
        this.debug('Current transport state is %s', state.transportState);
        // Play all notifications (if calls itself if notifications where added in between)
        const shouldRevert = await this.PlayNextNotification(state.transportState);
        if (shouldRevert) {
            // Revert everything back
            this.debug('Reverting everything back to normal');
            await this.RestoreState(state, options.delayMs).catch((reason) => {
                this.debug('Restoring state failed %s', reason);
            });
        }
        this.playingNotification = undefined;
        return shouldRevert;
    }
    /**
     * Download the url for the specified text, play as a notification and revert back to current track.
     *
     * @param {PlayTtsOptions} options
     * @param {string} options.text Text to request a TTS file for.
     * @param {string} options.lang Language to request tts file for.
     * @param {string} [options.endpoint] TTS endpoint, see documentation, can also be set by environment variable 'SONOS_TTS_ENDPOINT'
     * @param {string} [options.gender] Supply gender, some languages support both genders.
     * @param {string} [options.name] Supply voice name, some services support several voices with different names.
     * @param {number} [options.delayMs] Delay in ms between commands, for better notification playback stability
     * @param {boolean} [options.onlyWhenPlaying] Only play a notification if currently playing music. You don't have to check if the user is home ;)
     * @param {number} [options.timeout] Number of seconds the notification should play, as a fallback if the event doesn't come through.
     * @param {number} [options.volume] Change the volume for the notification and revert afterwards.
     * @returns {Promise<boolean>} Returns when added to queue or (for the first) when all notifications have played.
     * @memberof SonosDevice
     */
    async PlayTTS(options) {
        this.debug('PlayTTS(%o)', options);
        const notificationOptions = await tts_helper_1.default.TtsOptionsToNotification(options);
        return await this.PlayNotification(notificationOptions);
    }
    async PlayNextNotification(originalState, havePlayed) {
        var _a;
        let result = havePlayed === true;
        // Remove and returns first item from queue
        const notification = this.notifications.shift();
        if (notification === undefined) {
            return Promise.resolve(result);
        }
        if (notification.onlyWhenPlaying === true && !(originalState === models_1.TransportState.Playing || originalState === models_1.TransportState.Transitioning)) {
            this.debug('Skip notification, because of not playing %s', notification.trackUri);
            if (notification.notificationFired !== undefined) {
                notification.notificationFired(false);
            }
        }
        else {
            result = true;
            this.debug('Start notification playback uri %s', notification.trackUri);
            await this.AVTransportService.SetAVTransportURI({ InstanceID: 0, CurrentURI: notification.trackUri, CurrentURIMetaData: (_a = notification.metadata) !== null && _a !== void 0 ? _a : '' })
                .catch((reason) => { this.debug('SetAVTransportURI failed', reason); });
            if (notification.volume !== undefined && notification.volume !== this.volume) {
                await this.SetVolume(notification.volume)
                    .catch((reason) => { this.debug('Setting volume failed', reason); });
                if (notification.delayMs !== undefined)
                    await async_helper_1.default.Delay(notification.delayMs);
            }
            await this.AVTransportService.Play({ InstanceID: 0, Speed: '1' })
                .catch((err) => { this.debug('Play threw error, wrong url? %o', err); });
            // Wait for event (or timeout)
            await async_helper_1.default.AsyncEvent(this.Events, models_1.SonosEvents.PlaybackStopped, notification.timeout).catch((err) => this.debug(err));
            if (notification.notificationFired !== undefined) {
                notification.notificationFired(true);
            }
        }
        return this.PlayNextNotification(originalState, result);
    }
    /**
     * A second implementation of PlayNotification.
     *
     * @param {PlayNotificationOptions} options The options
     * @param {string} [options.trackUri] The uri of the sound to play as notification, can be every supported sonos uri.
     * @param {string|Track} [options.metadata] The metadata of the track to play, will be guesses if undefined.
     * @param {number} [options.delayMs] Delay in ms between commands, for better notification playback stability. Use 100 to 800 for best results
     * @param {boolean} [options.onlyWhenPlaying] Only play a notification if currently playing music. You don't have to check if the user is home ;)
     * @param {number} [options.timeout] Number of seconds the notification should play, as a fallback if the event doesn't come through.
     * @param {number} [options.volume] Change the volume for the notification and revert afterwards.
     * @param {boolean} [options.resolveAfterRevert]
     * @param {number} [options.defaultTimeout]
     * @param {number} [options.specificTimeout]
     * @param {boolean} [options.catchQueueErrors]
     *
     * @deprecated This is experimental, do not depend on this. (missing the jsdocs experimental descriptor)
     * @remarks This is just added to be able to test the two implementations next to each other. This will probably be removed in feature.
     */
    async PlayNotificationTwo(options) {
        if (this.notificationsTwo === undefined) {
            this.notificationsTwo = new sonos_notification_two_1.default(this.AVTransportService, this.RenderingControlService, this.Events);
        }
        return this.notificationsTwo.PlayNotificationTwo(options);
    }
    /**
     * Download the url for the specified text, play as a notification and revert back to current track.
     *
     * @param {PlayTtsOptions} options
     * @param {string} options.text Text to request a TTS file for.
     * @param {string} options.lang Language to request tts file for.
     * @param {string} [options.endpoint] TTS endpoint, see documentation, can also be set by environment variable 'SONOS_TTS_ENDPOINT'
     * @param {string} [options.gender] Supply gender, some languages support both genders.
     * @param {string} [options.name] Supply voice name, some services support several voices with different names.
     * @param {number} [options.delayMs] Delay in ms between commands, for better notification playback stability
     * @param {boolean} [options.onlyWhenPlaying] Only play a notification if currently playing music. You don't have to check if the user is home ;)
     * @param {number} [options.timeout] Number of seconds the notification should play, as a fallback if the event doesn't come through.
     * @param {number} [options.volume] Change the volume for the notification and revert afterwards.
     * @param {boolean} [options.resolveAfterRevert]
     * @param {number} [options.defaultTimeout]
     * @param {number} [options.specificTimeout]
     * @param {boolean} [options.catchQueueErrors]
     * @deprecated TTS using experimental notification feature
     * @returns {Promise<boolean>} Returns when added to queue or (for the first) when all notifications have played.
     * @memberof SonosDevice
     */
    async PlayTTSTwo(options) {
        this.debug('PlayTTSTwo(%o)', options);
        const notificationOptions = await tts_helper_1.default.TtsOptionsToNotification(options);
        return await this.PlayNotificationTwo(Object.assign(Object.assign({}, notificationOptions), { catchQueueErrors: options.catchQueueErrors, resolveAfterRevert: options.resolveAfterRevert, defaultTimeout: options.defaultTimeout, specificTimeout: options.specificTimeout }));
    }
    // #endregion
    /**
     * Switch the playback to this url.
     *
     * @param {string} trackUri
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async SetAVTransportURI(trackUri) {
        const guessedMetaData = metadata_helper_1.default.GuessMetaDataAndTrackUri(trackUri);
        return await this.AVTransportService.SetAVTransportURI({ InstanceID: 0, CurrentURI: guessedMetaData.trackUri, CurrentURIMetaData: guessedMetaData.metadata });
    }
    /**
     * Switch playback to line in (which will always be playing)
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async SwitchToLineIn() {
        await this.LoadUuid();
        await this.AVTransportService
            .SetAVTransportURI({ InstanceID: 0, CurrentURI: `x-rincon-stream:${this.uuid}`, CurrentURIMetaData: '' });
        return await this.Play();
    }
    /**
     * Switch playback to the queue
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async SwitchToQueue() {
        await this.LoadUuid();
        return await this.AVTransportService
            .SetAVTransportURI({ InstanceID: 0, CurrentURI: `x-rincon-queue:${this.uuid}#0`, CurrentURIMetaData: '' });
    }
    /**
     * Switch playback to TV Input (only on Playbar)
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async SwitchToTV() {
        await this.LoadUuid();
        await this.AVTransportService
            .SetAVTransportURI({ InstanceID: 0, CurrentURI: `x-sonos-htastream:${this.uuid}:spdif`, CurrentURIMetaData: '' });
        return await this.Play();
    }
    /**
     * Toggle playback between paused and playing
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async TogglePlayback() {
        // Load the Current state first, if not present (eg. not using events)
        const currentState = this.Coordinator.CurrentTransportStateSimple || (await this.Coordinator.AVTransportService.GetTransportInfo()).CurrentTransportState;
        return currentState === models_1.TransportState.Playing || currentState === models_1.TransportState.Transitioning
            ? await this.Coordinator.Pause()
            : await this.Coordinator.Play();
    }
    /**
     * Cancel all subscriptions and unsubscribe for events from this device.
     *
     * @memberof SonosDevice
     */
    CancelEvents() {
        if (this.events !== undefined) {
            const eventNames = this.events.eventNames().filter((e) => e !== 'removeListener' && e !== 'newListener' && e !== models_1.SonosEvents.SubscriptionError);
            eventNames.forEach((e) => {
                if (this.events !== undefined)
                    this.events.removeAllListeners(e);
            });
        }
    }
    /**
     * Access to the sonos event emitter. All the possible events are in the SonosEvents enum.
     * Calling this will automatically subscribe for events from the device.
     *
     * @readonly
     * @type {EventEmitter}
     * @memberof SonosDevice
     */
    get Events() {
        if (this.events !== undefined) {
            return this.events;
        }
        // this.events = new EventEmitter() as TypedEmitter<StrongSonosEvents>; incorrect according to DeepSource
        this.events = new events_1.EventEmitter();
        this.events.on('removeListener', (eventName) => {
            var _a, _b;
            this.debug('Listener removed for %s', eventName);
            if (eventName === models_1.SonosEvents.SubscriptionError)
                return;
            const events = this.Events.eventNames().filter((e) => e !== 'removeListener' && e !== 'newListener' && e !== models_1.SonosEvents.SubscriptionError);
            if (events.length === 0) {
                this.AVTransportService.Events.removeListener(models_1.ServiceEvents.ServiceEvent, this.boundHandleAvTransportEvent);
                this.AVTransportService.Events.removeListener(models_1.ServiceEvents.SubscriptionError, this.boundHandleEventErrorEvent);
                this.RenderingControlService.Events.removeListener(models_1.ServiceEvents.ServiceEvent, this.boundHandleRenderingControlEvent);
                this.RenderingControlService.Events.removeListener(models_1.ServiceEvents.SubscriptionError, this.boundHandleEventErrorEvent);
                (_b = (_a = this.coordinator) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.removeListener('simpleTransportState', this.boundHandleCoordinatorSimpleStateEvent);
                this.isSubscribed = false;
            }
        });
        this.events.on('newListener', (eventName) => {
            var _a;
            this.debug('Listener added for %s (isSubscribed: %o)', eventName, this.isSubscribed);
            if (eventName === models_1.SonosEvents.SubscriptionError)
                return;
            if (!this.isSubscribed) {
                this.isSubscribed = true;
                this.AVTransportService.Events.on(models_1.ServiceEvents.SubscriptionError, this.boundHandleEventErrorEvent);
                this.AVTransportService.Events.on(models_1.ServiceEvents.ServiceEvent, this.boundHandleAvTransportEvent);
                this.RenderingControlService.Events.on(models_1.ServiceEvents.SubscriptionError, this.boundHandleEventErrorEvent);
                this.RenderingControlService.Events.on(models_1.ServiceEvents.ServiceEvent, this.boundHandleRenderingControlEvent);
                if (this.coordinator !== undefined) {
                    (_a = this.coordinator) === null || _a === void 0 ? void 0 : _a.Events.on('simpleTransportState', this.boundHandleCoordinatorSimpleStateEvent);
                    this.boundHandleCoordinatorSimpleStateEvent(this.coordinator.CurrentTransportStateSimple);
                }
            }
        });
        return this.events;
    }
    handleEventErrorEvent(err) {
        if (this.events !== undefined) {
            this.events.emit(models_1.SonosEvents.SubscriptionError, err);
        }
    }
    handleAvTransportEvent(data) {
        var _a, _b, _c;
        this.Events.emit(models_1.SonosEvents.AVTransport, data);
        if (data.TransportState !== undefined && this.coordinator === undefined) {
            const newState = data.TransportState;
            const newSimpleState = newState === models_1.TransportState.Paused || newState === models_1.TransportState.Stopped ? models_1.TransportState.Stopped : models_1.TransportState.Playing;
            this.debug('Received TransportState new State "%s" newSimpleState "%s"', newState, newSimpleState);
            if (newSimpleState !== this.CurrentTransportStateSimple)
                this.Events.emit(models_1.SonosEvents.CurrentTransportStateSimple, newSimpleState);
            if (this.currentTransportState !== newState) {
                this.currentTransportState = newState;
                this.Events.emit(models_1.SonosEvents.CurrentTransportState, newState);
                if (newState === models_1.TransportState.Stopped)
                    this.Events.emit(models_1.SonosEvents.PlaybackStopped);
            }
        }
        if (data.CurrentTrackURI && this.currentTrackUri !== data.CurrentTrackURI) {
            this.currentTrackUri = data.CurrentTrackURI;
            this.Events.emit(models_1.SonosEvents.CurrentTrackUri, (_a = this.currentTrackUri) !== null && _a !== void 0 ? _a : '');
        }
        if (data.CurrentTrackMetaData && typeof data.CurrentTrackMetaData !== 'string')
            this.Events.emit(models_1.SonosEvents.CurrentTrackMetadata, data.CurrentTrackMetaData);
        if (data.NextTrackURI && this.nextTrackUri !== data.NextTrackURI) {
            this.nextTrackUri = data.NextTrackURI;
            this.Events.emit(models_1.SonosEvents.NextTrackUri, (_b = this.nextTrackUri) !== null && _b !== void 0 ? _b : '');
            if (data.NextTrackMetaData && typeof data.NextTrackMetaData !== 'string')
                this.Events.emit(models_1.SonosEvents.NextTrackMetadata, data.NextTrackMetaData);
        }
        if (data.EnqueuedTransportURI && this.enqueuedTransportUri !== data.EnqueuedTransportURI) {
            this.enqueuedTransportUri = data.EnqueuedTransportURI;
            this.Events.emit(models_1.SonosEvents.EnqueuedTransportUri, (_c = this.enqueuedTransportUri) !== null && _c !== void 0 ? _c : '');
            if (data.EnqueuedTransportURIMetaData !== undefined && typeof data.EnqueuedTransportURIMetaData !== 'string')
                this.Events.emit(models_1.SonosEvents.EnqueuedTransportMetadata, data.EnqueuedTransportURIMetaData);
        }
        if (data.CurrentPlayMode) {
            this.currentPlayMode = data.CurrentPlayMode;
        }
    }
    handleRenderingControlEvent(data) {
        var _a;
        this.Events.emit(models_1.SonosEvents.RenderingControl, data);
        if (data.Volume && data.Volume.Master && this.volume !== data.Volume.Master) {
            this.volume = data.Volume.Master;
            this.Events.emit(models_1.SonosEvents.Volume, (_a = this.volume) !== null && _a !== void 0 ? _a : 0);
        }
        if (data.Mute && this.muted !== data.Mute.Master) {
            this.muted = data.Mute.Master;
            this.Events.emit(models_1.SonosEvents.Mute, this.muted);
        }
    }
    handleCoordinatorSimpleStateEvent(state) {
        var _a;
        const newState = state === models_1.TransportState.Playing ? models_1.GroupTransportState.GroupPlaying : models_1.GroupTransportState.GroupStopped;
        (_a = this.events) === null || _a === void 0 ? void 0 : _a.emit('transportState', newState);
        this.currentTransportState = newState;
    }
    handleGroupUpdate(data) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (data.coordinator && ((_a = data.coordinator) === null || _a === void 0 ? void 0 : _a.uuid) !== this.Uuid && (!this.coordinator || ((_b = this.coordinator) === null || _b === void 0 ? void 0 : _b.Uuid) !== ((_c = data.coordinator) === null || _c === void 0 ? void 0 : _c.Uuid))) {
            this.debug('Coordinator changed for %s', this.uuid);
            (_e = (_d = this.coordinator) === null || _d === void 0 ? void 0 : _d.events) === null || _e === void 0 ? void 0 : _e.removeListener('simpleTransportState', this.boundHandleCoordinatorSimpleStateEvent);
            this.coordinator = data.coordinator;
            if (this.events !== undefined) {
                // this.boundHandleCoordinatorSimpleStateEvent(this.coordinator.CurrentTransportStateSimple);
                this.events.emit(models_1.SonosEvents.Coordinator, this.coordinator.uuid);
                (_f = this.coordinator) === null || _f === void 0 ? void 0 : _f.Events.on('simpleTransportState', this.boundHandleCoordinatorSimpleStateEvent);
                setTimeout(() => {
                    var _a;
                    this.boundHandleCoordinatorSimpleStateEvent((_a = this.coordinator) === null || _a === void 0 ? void 0 : _a.CurrentTransportStateSimple);
                }, 50);
            }
        }
        if (this.coordinator && (data.coordinator === undefined || data.coordinator.uuid === this.uuid)) {
            this.debug('Coordinator removed for %s', this.uuid);
            (_h = (_g = this.coordinator) === null || _g === void 0 ? void 0 : _g.events) === null || _h === void 0 ? void 0 : _h.removeListener('simpleTransportState', this.boundHandleCoordinatorSimpleStateEvent);
            this.coordinator = undefined;
            if (this.events !== undefined) {
                this.events.emit(models_1.SonosEvents.Coordinator, this.uuid);
                this.currentTransportState = undefined;
                this.events.emit(models_1.SonosEvents.CurrentTransportState, models_1.TransportState.Stopped);
                this.events.emit(models_1.SonosEvents.CurrentTransportStateSimple, models_1.TransportState.Stopped);
            }
        }
        if (data.name && data.name !== this.groupName) {
            this.groupName = data.name;
            this.debug('Groupname changed for %s to %s', this.uuid, this.groupName);
            if (this.events !== undefined) {
                this.events.emit(models_1.SonosEvents.GroupName, this.groupName);
            }
        }
    }
    /**
     * Get the current coordinator for this group, or the device itself if if doesn't have a coordinator.
     *
     * @readonly
     * @type {SonosDevice}
     * @memberof SonosDevice
     */
    get Coordinator() {
        return this.coordinator || this;
    }
    /**
     * Get the GroupName, if device is created by the SonosManager.
     *
     * @readonly
     * @type {(string | undefined)}
     * @memberof SonosDevice
     */
    get GroupName() {
        return this.groupName;
    }
    /**
     * Current play mode, only set when subscribed to events.
     *
     * @readonly
     * @type {(string | undefined)}
     * @memberof SonosDevice
     */
    get CurrentPlayMode() {
        return this.currentPlayMode;
    }
    /**
     * Current track uri, only set when subscribed to events.
     *
     * @readonly
     * @type {(string | undefined)}
     * @memberof SonosDevice
     */
    get CurrentTrackUri() {
        return this.currentTrackUri;
    }
    /**
     * Current EnqueuedTransportUri only set when listening to events
     *
     * @readonly
     * @type {(string | undefined)}
     * @memberof SonosDevice
     */
    get EnqueuedTransportUri() {
        return this.enqueuedTransportUri;
    }
    /**
     * Next Track Uri only set when listening to events
     *
     * @readonly
     * @type {(string | undefined)}
     * @memberof SonosDevice
     */
    get NextTrackUri() {
        return this.nextTrackUri;
    }
    /**
     * Current transport state, only set when listening for events
     *
     * @readonly
     * @type {(TransportState | undefined)}
     * @memberof SonosDevice
     */
    get CurrentTransportState() {
        return this.currentTransportState;
    }
    /**
     * Get the transportstate (from events) but with only two values TransportState.Stopped or TransportState.Playing
     *
     * @readonly
     * @type {(TransportState | undefined)}
     * @memberof SonosDevice
     */
    get CurrentTransportStateSimple() {
        var _a, _b;
        const state = (_b = (_a = this.coordinator) === null || _a === void 0 ? void 0 : _a.currentTransportState) !== null && _b !== void 0 ? _b : this.currentTransportState;
        if (state !== undefined) {
            return state === models_1.TransportState.Playing || state === models_1.TransportState.Transitioning ? models_1.TransportState.Playing : models_1.TransportState.Stopped;
        }
        return undefined;
    }
    /**
     * The IP of the speaker
     *
     * @readonly
     * @type {string}
     * @memberof SonosDevice
     */
    get Host() { return this.host; }
    /**
     * Device muted, only set when subscribed for events.
     *
     * @readonly
     * @type {(boolean | undefined)}
     * @memberof SonosDevice
     */
    get Muted() {
        return this.muted;
    }
    /**
     * Name of this player, set by manager or by calling LoadDeviceData()
     *
     * @readonly
     * @type {string}
     * @memberof SonosDevice
     */
    get Name() {
        if (this.name !== undefined)
            return this.name;
        if (this.zoneAttributes === undefined)
            throw new Error('Zone attributes not loaded');
        return this.zoneAttributes.CurrentZoneName;
    }
    get Port() { return this.port; }
    /**
     * UUID of the player, if set by the SonosManager or an guid otherwise.
     *
     * @readonly
     * @type {string}
     * @memberof SonosDevice
     */
    get Uuid() { return this.uuid; }
    /**
     * Current volume of the player, only set when subscribed for events.
     *
     * @readonly
     * @type {(number | undefined)}
     * @memberof SonosDevice
     */
    get Volume() {
        return this.volume;
    }
    // #endregion
    // #region Shortcuts
    /**
     * Get nightmode status of playbar.
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async GetNightMode() {
        return (await this.RenderingControlService.GetEQ({ InstanceID: 0, EQType: 'NightMode' })).CurrentValue === 1;
    }
    /**
     * Get Speech Enhancement status of playbar
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async GetSpeechEnhancement() {
        return (await this.RenderingControlService.GetEQ({ InstanceID: 0, EQType: 'DialogLevel' })).CurrentValue === 1;
    }
    /**
     * GetZoneAttributes shortcut to .DevicePropertiesService.GetZoneAttributes()
     *
     * @returns {Promise<GetZoneAttributesResponse>}
     * @memberof SonosDevice
     */
    async GetZoneAttributes() {
        this.zoneAttributes = await this.DevicePropertiesService.GetZoneAttributes();
        return this.zoneAttributes;
    }
    /**
     * GetZoneGroupState() shortcut to .ZoneGroupTopologyService.GetParsedZoneGroupState()
     *
     * @returns {Promise<ZoneGroup[]>}
     * @memberof SonosDevice
     */
    async GetZoneGroupState() { return await this.ZoneGroupTopologyService.GetParsedZoneGroupState(); }
    /**
     * GetZoneInfo shortcut to .DevicePropertiesService.GetZoneInfo()
     *
     * @returns {Promise<GetZoneInfoResponse>}
     * @memberof SonosDevice
     */
    async GetZoneInfo() { return await this.DevicePropertiesService.GetZoneInfo(); }
    /**
     * Play next song, shortcut to .Coordinator.AVTransportService.Next()
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async Next() { return await this.Coordinator.AVTransportService.Next(); }
    /**
     * Pause playback, shortcut to .Coordinator.AVTransportService.Pause()
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async Pause() { return await this.Coordinator.AVTransportService.Pause(); }
    /**
     * Start playing, shortcut to .Coordinator.AVTransportService.Play({InstanceID: 0, Speed: '1'})
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async Play() { return await this.Coordinator.AVTransportService.Play({ InstanceID: 0, Speed: '1' }); }
    /**
     * Play previous song, shortcut to .Coordinator.AVTransportService.Previous()
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async Previous() { return await this.Coordinator.AVTransportService.Previous(); }
    /**
     * Seek position in the current track, shortcut to .Coordinator.AVTransportService.Seek({InstanceID: 0, Unit: 'REL_TIME', Target: trackTime})
     *
     * @param {string} trackTime
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async SeekPosition(trackTime) { return await this.Coordinator.AVTransportService.Seek({ InstanceID: 0, Unit: 'REL_TIME', Target: trackTime }); }
    /**
     * Go to other track in queue, shortcut to .Coordinator.AVTransportService.Seek({InstanceID: 0, Unit: 'TRACK_NR', Target: trackNr.toString()})
     *
     * @param {number} trackNr The track number to go to.
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async SeekTrack(trackNr) { return await this.Coordinator.AVTransportService.Seek({ InstanceID: 0, Unit: 'TRACK_NR', Target: trackNr.toString() }); }
    /**
     * Turn on/off night mode, on your playbar.
     * shortcut to .RenderingControlService.SetEQ({ InstanceID: 0, EQType: 'NightMode', DesiredValue: dialogLevel === true ? 1 : 0 })
     *
     * @param {boolean} nightmode
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async SetNightMode(nightmode) {
        return await this.RenderingControlService
            .SetEQ({ InstanceID: 0, EQType: 'NightMode', DesiredValue: nightmode === true ? 1 : 0 });
    }
    /**
     * Set relative group volume, shortcut to .Coordinator.GroupRenderingControlService.SetRelativeGroupVolume({ InstanceID: 0, Adjustment: volumeAdjustment })
     *
     * @param {number} volumeAdjustment the adjustment, positive or negative
     * @returns {Promise<number>}
     * @memberof SonosDevice
     */
    async SetRelativeGroupVolume(volumeAdjustment) {
        return await this.Coordinator.GroupRenderingControlService.SetRelativeGroupVolume({ InstanceID: 0, Adjustment: volumeAdjustment })
            .then((response) => response.NewVolume);
    }
    /**
     * Set relative volume, shortcut to .RenderingControlService.SetRelativeVolume({ InstanceID: 0, Channel: 'Master', Adjustment: volumeAdjustment })
     *
     * @param {number} volumeAdjustment the adjustment, positive or negative
     * @returns {Promise<number>}
     * @memberof SonosDevice
     * @remarks Also saves the volume so it can be used by other methods that need the volume (and events aren't working)
     */
    async SetRelativeVolume(volumeAdjustment) {
        return await this.RenderingControlService.SetRelativeVolume({ InstanceID: 0, Channel: 'Master', Adjustment: volumeAdjustment })
            .then((response) => {
            this.volume = response.NewVolume;
            return response.NewVolume;
        });
    }
    /**
     * Turn on/off speech enhancement, on your playbar,
     * shortcut to .RenderingControlService.SetEQ({ InstanceID: 0, EQType: 'DialogLevel', DesiredValue: dialogLevel === true ? 1 : 0 })
     *
     * @param {boolean} dialogLevel
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async SetSpeechEnhancement(dialogLevel) {
        return await this.RenderingControlService
            .SetEQ({ InstanceID: 0, EQType: 'DialogLevel', DesiredValue: dialogLevel === true ? 1 : 0 });
    }
    /**
     * Set the volume, shortcut to .RenderingControlService.SetVolume({InstanceID: 0, Channel: 'Master', DesiredVolume: volume});
     *
     * @param {number} volume new Volume (between 0 and 100)
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     * @remarks Also saves the volume so it can be used by other methods that need the volume (and events aren't working)
     */
    async SetVolume(volume) {
        if (volume < 0 || volume > 100)
            throw new Error('Volume should be between 0 and 100');
        return await this.RenderingControlService
            .SetVolume({ InstanceID: 0, Channel: 'Master', DesiredVolume: volume })
            .then((result) => {
            if (result === true && this.volume !== volume) {
                this.volume = volume;
            }
            return result;
        });
    }
    /**
     * Stop playback, shortcut to .Coordinator.AVTransportService.Stop()
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    async Stop() { return await this.Coordinator.AVTransportService.Stop(); }
}
exports.default = SonosDevice;
//# sourceMappingURL=sonos-device.js.map