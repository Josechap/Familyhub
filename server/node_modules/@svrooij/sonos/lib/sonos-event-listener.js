"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-param-reassign */
const os_1 = require("os");
const http_1 = require("http");
const debug_1 = __importDefault(require("debug"));
/**
 * SonosEventListener is the internal webservice to handle events.
 *
 * @description the SonosEventListener is created automatically by the first service you start using. You should not call this service by yourself!
 * @export
 * @internal
 * @class SonosEventListener
 */
class SonosEventListener {
    constructor() {
        this.proxyHost = process.env.SONOS_LISTENER_PROXY;
        this.subscriptions = {};
        this.debug = debug_1.default('sonos:eventlistener');
        this.listenerHost = process.env.SONOS_LISTENER_HOST || SonosEventListener.getHostIp();
        this.port = parseInt((process.env.SONOS_LISTENER_PORT || '6329'), 10);
        this.server = http_1.createServer((req, resp) => this.requestHandler(req, resp));
        this.debug('Listener endpoint: %s', this.GetEndpoint('{sonos-uuid}', '{serviceName}'));
    }
    static get DefaultInstance() {
        if (!SonosEventListener.instance) {
            SonosEventListener.instance = new SonosEventListener();
        }
        return SonosEventListener.instance;
    }
    static getHostIp() {
        const ifaces = os_1.networkInterfaces();
        let interfaces = Object.keys(ifaces).filter((k) => k !== 'lo0');
        if (process.env.SONOS_LISTENER_INTERFACE) {
            interfaces = interfaces.filter((i) => i === process.env.SONOS_LISTENER_INTERFACE);
        }
        else {
            // Remove unwanted interfaces on windows
            interfaces = interfaces.filter((i) => i.indexOf('vEthernet') === -1
                && i.indexOf('tun') === -1);
        }
        if (interfaces === undefined || interfaces.length === 0) {
            throw new Error('No network interfaces found');
        }
        let address;
        interfaces.every((inf) => {
            const currentInterface = ifaces[inf];
            if (currentInterface === undefined)
                return true;
            const info = currentInterface.find((i) => i.family === 'IPv4' && i.internal === false);
            if (info !== undefined) {
                address = info.address;
                return false;
            }
            return true;
        });
        if (address !== undefined)
            return address;
        throw new Error('No non-internal ipv4 addresses found');
    }
    get isListening() {
        return this.listenerStarted === true; // && this.server.listening;
    }
    /**
     * Change the settings of the event listener.
     * @param {string?} settings.host - The new host
     * @param {number?} settings.port - The new port - cannot be changed when listener already started
     *
     * @remarks Will only change the host for new subscriptions
     * @returns Returns true is settings where changed and false if settings where not changed (already running)
     */
    UpdateSettings(settings) {
        this.debug('Updating settings host: %s, port: %d', settings.host, settings.port);
        if (settings.port !== undefined) {
            if (this.isListening) {
                return false;
            }
            this.port = settings.port;
        }
        if (settings.host !== undefined) {
            this.listenerHost = settings.host;
        }
        this.debug('New Listener endpoint: %s', this.GetEndpoint('{sonos-uuid}', '{serviceName}'));
        return true;
    }
    requestHandler(req, resp) {
        if (req.url) {
            if (req.url.indexOf('/sonos/') > -1) {
                return this.handleSonosRequest(req, resp);
            }
            if (req.url.endsWith('/status')) {
                return this.handleStatusRequest(req, resp);
            }
            if (req.url.endsWith('/health')) {
                return this.handleHealthRequest(req, resp);
            }
        }
        resp.statusCode = 404;
        return resp.end();
    }
    handleHealthRequest(req, resp) {
        resp.statusCode = 200;
        resp.end();
    }
    handleStatusRequest(req, resp) {
        SonosEventListener.WriteJson(resp, this.GetStatus());
    }
    static WriteJson(resp, data) {
        resp.statusCode = 200;
        resp.setHeader('Content-Type', 'application/json');
        resp.write(JSON.stringify(data));
        resp.end();
    }
    handleSonosRequest(req, resp) {
        const index = req.rawHeaders.findIndex((v) => v === 'SID') + 1;
        const sid = req.rawHeaders[index];
        this.debug('Got event on %s SID: %s', req.url, sid);
        const service = this.subscriptions[sid];
        if (service === undefined) {
            this.debug('Subscription %s not found, sending 412 to stop messages', sid);
            resp.statusCode = 412;
            resp.end();
            return;
        }
        const body = [];
        req
            .on('data', (chunk) => { body.push(chunk); })
            .on('end', () => {
            const bodyString = Buffer.concat(body).toString();
            resp.statusCode = 200;
            resp.end('OK');
            // End response before parsing event.
            service.ParseEvent(bodyString);
        })
            .on('error', (err) => {
            this.debug('Error receiving event', err);
        });
    }
    /**
     * Get Endpoint generates the url where the sonos speaker should send it's events.
     * @param uuid The UUID of the sonos speaker
     * @param serviceName The name of the service
     * @remarks Even though this is public, it should not be called by external applications.
     */
    GetEndpoint(uuid, serviceName) {
        const suffix = `sonos/${uuid}/${serviceName}`;
        if (this.proxyHost) {
            return `${this.proxyHost}/${suffix}`;
        }
        return `http://${this.listenerHost}:${this.port}/${suffix}`;
    }
    /**
     * Get debug information about the listener.
     */
    GetStatus() {
        return {
            host: this.listenerHost,
            port: this.port,
            isListening: this.isListening,
            subscriptionUrl: this.GetEndpoint('{sonos-uuid}', '{serviceName}'),
            listeningSince: this.listeningSince,
            subscriptionCount: Object.keys(this.subscriptions).length,
            currentSubscriptions: this.GetSubscriptions(),
        };
    }
    /**
     * Get all active subscriptions
     * @remarks Subscriptions are automatically unregistered, but this doesn't always succeed
     */
    GetSubscriptions() {
        return Object.entries(this.subscriptions)
            .map(([key, value]) => ({
            sid: key,
            uuid: value.Uuid,
            host: value.Host,
            service: value.serviceNane,
        }));
    }
    /**
     * Register subscription lets the events listener forward the events to the correct service.
     * @param sid Sonos subscription id
     * @param service Instance of the service that will receive the events'
     *
     * @remarks Even though this is public, it should not be called by external applications.
     */
    RegisterSubscription(sid, service) {
        this.StartListener();
        this.subscriptions[sid] = service;
    }
    /**
     * Unregister the subscription, this means that the service will no longer receive these events.
     * @param sid The old subscription ID
     * @remarks Even though this is public, it should not be called by external applications.
     */
    UnregisterSubscription(sid) {
        if (typeof sid === 'string' && this.subscriptions[sid]) {
            delete this.subscriptions[sid];
        }
    }
    /**
     * Start the event listener, in case you want the status endpoint without an actual event subscription.
     *
     * @remarks The event listener is started automatically, so you probably don't need to start it yourself.
     */
    StartListener(cb = undefined) {
        if (!this.isListening) {
            this.debug('Starting event listener on port %d', this.port);
            this.listenerStarted = true;
            this.listeningSince = new Date();
            if (!this.server.listening && !process.env.SONOS_DISABLE_LISTENER) {
                this.server.listen(this.port, cb);
            }
            else if (cb !== undefined) {
                cb();
            }
        }
    }
    /**
     * Stop the event listener.
     */
    async StopListener() {
        return new Promise((resolve, reject) => {
            if (process.env.SONOS_DISABLE_LISTENER || (this.isListening !== true && this.server.listening !== true)) {
                Object.keys(this.subscriptions).forEach((sid) => this.UnregisterSubscription(sid));
                resolve();
                return;
            }
            this.listeningSince = undefined;
            this.listenerStarted = false;
            Object.keys(this.subscriptions).forEach((sid) => this.UnregisterSubscription(sid));
            const timer = setTimeout(() => {
                reject(new Error('Listener not closed before timeout'));
            }, 1000);
            this.server.close((err) => {
                this.listenerStarted = undefined;
                if (timer) {
                    clearTimeout(timer);
                }
                if (err) {
                    reject(err);
                    return;
                }
                resolve();
            });
        });
    }
}
exports.default = SonosEventListener;
//# sourceMappingURL=sonos-event-listener.js.map