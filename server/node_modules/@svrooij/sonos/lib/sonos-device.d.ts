/// <reference types="node" />
import { EventEmitter } from 'events';
import TypedEmitter from 'typed-emitter';
import SonosDeviceBase from './sonos-device-base';
import { GetZoneInfoResponse, GetZoneAttributesResponse, AddURIToQueueResponse, MusicService } from './services';
import { PlayNotificationOptions, Alarm, TransportState, ExtendedTransportState, PatchAlarm, PlayTtsOptions, BrowseResponse, ZoneGroup, PlayMode } from './models';
import { StrongSonosEvents } from './models/strong-sonos-events';
import { SmapiClient } from './musicservices/smapi-client';
import DeviceDescription from './models/device-description';
import { SonosState } from './models/sonos-state';
import { PlayNotificationTwoOptions, PlayTtsTwoOptions } from './models/notificationQueue';
/**
 * Main class to control a single sonos device.
 *
 * @export
 * @class SonosDevice
 * @extends {SonosDeviceBase}
 */
export default class SonosDevice extends SonosDeviceBase {
    private name;
    private groupName;
    private coordinator;
    /**
     * Creates an instance of SonosDevice.
     * @param {string} host the ip or host of the speaker you want to add
     * @param {number} [port=1400] the port (is always 1400)
     * @param {(string | undefined)} [uuid=undefined] the uuid of the speaker, is set by the SonosManager. like RINCON_macaddres01400, used in some commands
     * @param {(string | undefined)} [name=undefined] the name of the speaker, is set by the SonosManager by default
     * @param {({coordinator?: SonosDevice; name: string; managerEvents: EventEmitter} | undefined)} [groupConfig=undefined] groupConfig is used by the SonosManager to setup group change events.
     * @memberof SonosDevice
     */
    constructor(host: string, port?: number, uuid?: string | undefined, name?: string | undefined, groupConfig?: {
        coordinator?: SonosDevice;
        name: string;
        managerEvents: EventEmitter;
    } | undefined);
    /**
     * Preload some device data, should be called before accessing most properties of this class.
     *
     * @returns {Promise<boolean>} Either returns true or throws an error
     * @memberof SonosDevice
     */
    LoadDeviceData(): Promise<boolean>;
    /**
     * Add One track to the queue
     *
     * @param {string} trackUri
     * @param {number} [positionInQueue=0]
     * @param {boolean} [enqueueAsNext=true]
     * @returns {Promise<AddURIToQueueResponse>}
     * @memberof SonosDevice
     */
    AddUriToQueue(trackUri: string, positionInQueue?: number, enqueueAsNext?: boolean): Promise<AddURIToQueueResponse>;
    /**
     * Get a parsed list of all alarms.
     *
     * @returns {Promise<Alarm[]>}
     * @deprecated Will be removed in favor of Extended AlarmClockService
     * @memberof SonosDevice
     */
    AlarmList(): Promise<Alarm[]>;
    /**
     * Patch a single alarm. Only the ID and one property you want to change are required.
     *
     * @param {PatchAlarm} [options]
     * @param {number} options.ID The ID of the alarm to update
     * @param {string | undefined} options.StartLocalTime The time the alarm has to start 'hh:mm:ss'
     * @param {string | undefined} options.Duration The duration of the alarm 'hh:mm:ss'
     * @param {string | undefined} options.Recurrence What should the recurrence be ['DAILY','ONCE','WEEKDAYS']
     * @param {boolean | undefined} options.Enabled Should this alarm be enabled
     * @param {PlayMode | undefined} options.PlayMode What playmode should be used
     * @param {number | undefined} options.Volume The requested alarm volume
     * @deprecated Will be removed in favor of Extended AlarmClockService
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    AlarmPatch(options: PatchAlarm): Promise<boolean>;
    /**
     * Execute any sonos command by name, see examples/commands.js
     *
     * @param {string} command Command you wish to execute, like 'Play' or 'AVTransportService.Pause'. CASE SENSITIVE!!!
     * @param {(string | unknown | number | undefined)} options If the function requires options specify them here. A json string is automatically parsed to an object (if possible).
     * @returns {Promise<unknown>}
     * @memberof SonosDevice
     */
    ExecuteCommand(command: string, options?: string | unknown | number): Promise<unknown>;
    private executeCommandGetFunctions;
    /**
     * Get the device description
     *
     * @returns {Promise<DeviceDescription>}
     * @memberof SonosDevice
     */
    GetDeviceDescription(): Promise<DeviceDescription>;
    /**
     * Get your favorite radio shows, just a browse shortcut.
     *
     * @returns {Promise<BrowseResponse>}
     * @memberof SonosDevice
     */
    GetFavoriteRadioShows(): Promise<BrowseResponse>;
    /**
     * Get your favorite radio stations, just a browse shortcut.
     *
     * @returns {Promise<BrowseResponse>}
     * @memberof SonosDevice
     */
    GetFavoriteRadioStations(): Promise<BrowseResponse>;
    /**
     * Get your favorite songs, just a browse shortcut.
     *
     * @returns {Promise<BrowseResponse>}
     * @memberof SonosDevice
     */
    GetFavorites(): Promise<BrowseResponse>;
    /**
     * Get the current queue, just a browse shortcut.
     *
     * @returns {Promise<BrowseResponse>}
     * @memberof SonosDevice
     */
    GetQueue(): Promise<BrowseResponse>;
    /**
     * Join this device to an other group, if you know the coordinator uuid you can do .AVTransportService.SetAVTransportURI({InstanceID: 0, CurrentURI: `x-rincon:${uuid}`, CurrentURIMetaData: ''})
     *
     * @param {string} otherDevice The name of the other device, (to find the needed coordinator uuid)
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    JoinGroup(otherDevice: string): Promise<boolean>;
    LoadUuid(force?: boolean): Promise<string>;
    private deviceId?;
    /**
     * Create a client for a specific music service
     *
     * @param {number} id The id of the music service, see MusicServicesList
     * @param {string} options.key Cached authentication key
     * @param {string} options.authToken Cached authentication token
     * @returns {Promise<SmapiClient>}
     * @memberof SonosDevice
     */
    MusicServicesClient(serviceId: number, options?: {
        key?: string;
        authToken?: string;
    }): Promise<SmapiClient>;
    /**
     * Music services the user is logged-in to
     *
     * @returns {(Promise<Array<MusicService>>)}
     * @memberof SonosDevice
     */
    MusicServicesSubscribed(): Promise<Array<MusicService> | undefined>;
    /**
     * Get the state of the speaker, which can be reverted to with RestoreState
     */
    GetState(): Promise<SonosState>;
    /**
     * Restore to the state from before, used internally by the notification system.
     *
     * @param state The state of the speaker from 'GetState()'
     * @param delayBetweenCommands Sonos speakers cannot process commands fast after each other. use 50ms - 800ms for best results
     */
    RestoreState(state: SonosState, delayBetweenCommands?: number | undefined): Promise<boolean>;
    private notifications;
    private playingNotification?;
    /**
     * Play some url, and revert back to what was playing before. Very useful for playing a notification or TTS sound.
     *
     * @param {PlayNotificationOptions} options The options
     * @param {string} [options.trackUri] The uri of the sound to play as notification, can be every supported sonos uri.
     * @param {string|Track} [options.metadata] The metadata of the track to play, will be guesses if undefined.
     * @param {number} [options.delayMs] Delay in ms between commands, for better notification playback stability. Use 100 to 800 for best results
     * @param {callback} [options.notificationFired] Specify a callback that is called when this notification has played.
     * @param {boolean} [options.onlyWhenPlaying] Only play a notification if currently playing music. You don't have to check if the user is home ;)
     * @param {number} [options.timeout] Number of seconds the notification should play, as a fallback if the event doesn't come through.
     * @param {number} [options.volume] Change the volume for the notification and revert afterwards.
     * @returns {Promise<true>} Returns when added to queue or (for the first) when all notifications have played.
     * @remarks The first notification will return when all notifications have played, notifications send in between will return when added to the queue.
     * Use 'notificationFired' in the request if you want to know when your specific notification has played.
     * @memberof SonosDevice
     */
    PlayNotification(options: PlayNotificationOptions): Promise<boolean>;
    /**
     * Download the url for the specified text, play as a notification and revert back to current track.
     *
     * @param {PlayTtsOptions} options
     * @param {string} options.text Text to request a TTS file for.
     * @param {string} options.lang Language to request tts file for.
     * @param {string} [options.endpoint] TTS endpoint, see documentation, can also be set by environment variable 'SONOS_TTS_ENDPOINT'
     * @param {string} [options.gender] Supply gender, some languages support both genders.
     * @param {string} [options.name] Supply voice name, some services support several voices with different names.
     * @param {number} [options.delayMs] Delay in ms between commands, for better notification playback stability
     * @param {boolean} [options.onlyWhenPlaying] Only play a notification if currently playing music. You don't have to check if the user is home ;)
     * @param {number} [options.timeout] Number of seconds the notification should play, as a fallback if the event doesn't come through.
     * @param {number} [options.volume] Change the volume for the notification and revert afterwards.
     * @returns {Promise<boolean>} Returns when added to queue or (for the first) when all notifications have played.
     * @memberof SonosDevice
     */
    PlayTTS(options: PlayTtsOptions): Promise<boolean>;
    private PlayNextNotification;
    private notificationsTwo?;
    /**
     * A second implementation of PlayNotification.
     *
     * @param {PlayNotificationOptions} options The options
     * @param {string} [options.trackUri] The uri of the sound to play as notification, can be every supported sonos uri.
     * @param {string|Track} [options.metadata] The metadata of the track to play, will be guesses if undefined.
     * @param {number} [options.delayMs] Delay in ms between commands, for better notification playback stability. Use 100 to 800 for best results
     * @param {boolean} [options.onlyWhenPlaying] Only play a notification if currently playing music. You don't have to check if the user is home ;)
     * @param {number} [options.timeout] Number of seconds the notification should play, as a fallback if the event doesn't come through.
     * @param {number} [options.volume] Change the volume for the notification and revert afterwards.
     * @param {boolean} [options.resolveAfterRevert]
     * @param {number} [options.defaultTimeout]
     * @param {number} [options.specificTimeout]
     * @param {boolean} [options.catchQueueErrors]
     *
     * @deprecated This is experimental, do not depend on this. (missing the jsdocs experimental descriptor)
     * @remarks This is just added to be able to test the two implementations next to each other. This will probably be removed in feature.
     */
    PlayNotificationTwo(options: PlayNotificationTwoOptions): Promise<boolean>;
    /**
     * Download the url for the specified text, play as a notification and revert back to current track.
     *
     * @param {PlayTtsOptions} options
     * @param {string} options.text Text to request a TTS file for.
     * @param {string} options.lang Language to request tts file for.
     * @param {string} [options.endpoint] TTS endpoint, see documentation, can also be set by environment variable 'SONOS_TTS_ENDPOINT'
     * @param {string} [options.gender] Supply gender, some languages support both genders.
     * @param {string} [options.name] Supply voice name, some services support several voices with different names.
     * @param {number} [options.delayMs] Delay in ms between commands, for better notification playback stability
     * @param {boolean} [options.onlyWhenPlaying] Only play a notification if currently playing music. You don't have to check if the user is home ;)
     * @param {number} [options.timeout] Number of seconds the notification should play, as a fallback if the event doesn't come through.
     * @param {number} [options.volume] Change the volume for the notification and revert afterwards.
     * @param {boolean} [options.resolveAfterRevert]
     * @param {number} [options.defaultTimeout]
     * @param {number} [options.specificTimeout]
     * @param {boolean} [options.catchQueueErrors]
     * @deprecated TTS using experimental notification feature
     * @returns {Promise<boolean>} Returns when added to queue or (for the first) when all notifications have played.
     * @memberof SonosDevice
     */
    PlayTTSTwo(options: PlayTtsTwoOptions): Promise<boolean>;
    /**
     * Switch the playback to this url.
     *
     * @param {string} trackUri
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    SetAVTransportURI(trackUri: string): Promise<boolean>;
    /**
     * Switch playback to line in (which will always be playing)
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    SwitchToLineIn(): Promise<boolean>;
    /**
     * Switch playback to the queue
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    SwitchToQueue(): Promise<boolean>;
    /**
     * Switch playback to TV Input (only on Playbar)
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    SwitchToTV(): Promise<boolean>;
    /**
     * Toggle playback between paused and playing
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    TogglePlayback(): Promise<boolean>;
    private events?;
    private isSubscribed;
    /**
     * Cancel all subscriptions and unsubscribe for events from this device.
     *
     * @memberof SonosDevice
     */
    CancelEvents(): void;
    /**
     * Access to the sonos event emitter. All the possible events are in the SonosEvents enum.
     * Calling this will automatically subscribe for events from the device.
     *
     * @readonly
     * @type {EventEmitter}
     * @memberof SonosDevice
     */
    get Events(): TypedEmitter<StrongSonosEvents>;
    private boundHandleEventErrorEvent;
    private handleEventErrorEvent;
    private boundHandleAvTransportEvent;
    private handleAvTransportEvent;
    private boundHandleRenderingControlEvent;
    private handleRenderingControlEvent;
    private boundHandleCoordinatorSimpleStateEvent;
    private handleCoordinatorSimpleStateEvent;
    private boundHandleGroupUpdate;
    private handleGroupUpdate;
    /**
     * Get the current coordinator for this group, or the device itself if if doesn't have a coordinator.
     *
     * @readonly
     * @type {SonosDevice}
     * @memberof SonosDevice
     */
    get Coordinator(): SonosDevice;
    /**
     * Get the GroupName, if device is created by the SonosManager.
     *
     * @readonly
     * @type {(string | undefined)}
     * @memberof SonosDevice
     */
    get GroupName(): string | undefined;
    private currentPlayMode?;
    /**
     * Current play mode, only set when subscribed to events.
     *
     * @readonly
     * @type {(string | undefined)}
     * @memberof SonosDevice
     */
    get CurrentPlayMode(): PlayMode | undefined;
    private currentTrackUri?;
    /**
     * Current track uri, only set when subscribed to events.
     *
     * @readonly
     * @type {(string | undefined)}
     * @memberof SonosDevice
     */
    get CurrentTrackUri(): string | undefined;
    private enqueuedTransportUri?;
    /**
     * Current EnqueuedTransportUri only set when listening to events
     *
     * @readonly
     * @type {(string | undefined)}
     * @memberof SonosDevice
     */
    get EnqueuedTransportUri(): string | undefined;
    private nextTrackUri?;
    /**
     * Next Track Uri only set when listening to events
     *
     * @readonly
     * @type {(string | undefined)}
     * @memberof SonosDevice
     */
    get NextTrackUri(): string | undefined;
    private currentTransportState?;
    /**
     * Current transport state, only set when listening for events
     *
     * @readonly
     * @type {(TransportState | undefined)}
     * @memberof SonosDevice
     */
    get CurrentTransportState(): ExtendedTransportState | undefined;
    /**
     * Get the transportstate (from events) but with only two values TransportState.Stopped or TransportState.Playing
     *
     * @readonly
     * @type {(TransportState | undefined)}
     * @memberof SonosDevice
     */
    get CurrentTransportStateSimple(): TransportState | undefined;
    /**
     * The IP of the speaker
     *
     * @readonly
     * @type {string}
     * @memberof SonosDevice
     */
    get Host(): string;
    private muted?;
    /**
     * Device muted, only set when subscribed for events.
     *
     * @readonly
     * @type {(boolean | undefined)}
     * @memberof SonosDevice
     */
    get Muted(): boolean | undefined;
    /**
     * Name of this player, set by manager or by calling LoadDeviceData()
     *
     * @readonly
     * @type {string}
     * @memberof SonosDevice
     */
    get Name(): string;
    get Port(): number;
    /**
     * UUID of the player, if set by the SonosManager or an guid otherwise.
     *
     * @readonly
     * @type {string}
     * @memberof SonosDevice
     */
    get Uuid(): string;
    private volume?;
    /**
     * Current volume of the player, only set when subscribed for events.
     *
     * @readonly
     * @type {(number | undefined)}
     * @memberof SonosDevice
     */
    get Volume(): number | undefined;
    private zoneAttributes;
    /**
     * Get nightmode status of playbar.
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    GetNightMode(): Promise<boolean>;
    /**
     * Get Speech Enhancement status of playbar
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    GetSpeechEnhancement(): Promise<boolean>;
    /**
     * GetZoneAttributes shortcut to .DevicePropertiesService.GetZoneAttributes()
     *
     * @returns {Promise<GetZoneAttributesResponse>}
     * @memberof SonosDevice
     */
    GetZoneAttributes(): Promise<GetZoneAttributesResponse>;
    /**
     * GetZoneGroupState() shortcut to .ZoneGroupTopologyService.GetParsedZoneGroupState()
     *
     * @returns {Promise<ZoneGroup[]>}
     * @memberof SonosDevice
     */
    GetZoneGroupState(): Promise<ZoneGroup[]>;
    /**
     * GetZoneInfo shortcut to .DevicePropertiesService.GetZoneInfo()
     *
     * @returns {Promise<GetZoneInfoResponse>}
     * @memberof SonosDevice
     */
    GetZoneInfo(): Promise<GetZoneInfoResponse>;
    /**
     * Play next song, shortcut to .Coordinator.AVTransportService.Next()
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    Next(): Promise<boolean>;
    /**
     * Pause playback, shortcut to .Coordinator.AVTransportService.Pause()
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    Pause(): Promise<boolean>;
    /**
     * Start playing, shortcut to .Coordinator.AVTransportService.Play({InstanceID: 0, Speed: '1'})
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    Play(): Promise<boolean>;
    /**
     * Play previous song, shortcut to .Coordinator.AVTransportService.Previous()
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    Previous(): Promise<boolean>;
    /**
     * Seek position in the current track, shortcut to .Coordinator.AVTransportService.Seek({InstanceID: 0, Unit: 'REL_TIME', Target: trackTime})
     *
     * @param {string} trackTime
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    SeekPosition(trackTime: string): Promise<boolean>;
    /**
     * Go to other track in queue, shortcut to .Coordinator.AVTransportService.Seek({InstanceID: 0, Unit: 'TRACK_NR', Target: trackNr.toString()})
     *
     * @param {number} trackNr The track number to go to.
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    SeekTrack(trackNr: number): Promise<boolean>;
    /**
     * Turn on/off night mode, on your playbar.
     * shortcut to .RenderingControlService.SetEQ({ InstanceID: 0, EQType: 'NightMode', DesiredValue: dialogLevel === true ? 1 : 0 })
     *
     * @param {boolean} nightmode
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    SetNightMode(nightmode: boolean): Promise<boolean>;
    /**
     * Set relative group volume, shortcut to .Coordinator.GroupRenderingControlService.SetRelativeGroupVolume({ InstanceID: 0, Adjustment: volumeAdjustment })
     *
     * @param {number} volumeAdjustment the adjustment, positive or negative
     * @returns {Promise<number>}
     * @memberof SonosDevice
     */
    SetRelativeGroupVolume(volumeAdjustment: number): Promise<number>;
    /**
     * Set relative volume, shortcut to .RenderingControlService.SetRelativeVolume({ InstanceID: 0, Channel: 'Master', Adjustment: volumeAdjustment })
     *
     * @param {number} volumeAdjustment the adjustment, positive or negative
     * @returns {Promise<number>}
     * @memberof SonosDevice
     * @remarks Also saves the volume so it can be used by other methods that need the volume (and events aren't working)
     */
    SetRelativeVolume(volumeAdjustment: number): Promise<number>;
    /**
     * Turn on/off speech enhancement, on your playbar,
     * shortcut to .RenderingControlService.SetEQ({ InstanceID: 0, EQType: 'DialogLevel', DesiredValue: dialogLevel === true ? 1 : 0 })
     *
     * @param {boolean} dialogLevel
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    SetSpeechEnhancement(dialogLevel: boolean): Promise<boolean>;
    /**
     * Set the volume, shortcut to .RenderingControlService.SetVolume({InstanceID: 0, Channel: 'Master', DesiredVolume: volume});
     *
     * @param {number} volume new Volume (between 0 and 100)
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     * @remarks Also saves the volume so it can be used by other methods that need the volume (and events aren't working)
     */
    SetVolume(volume: number): Promise<boolean>;
    /**
     * Stop playback, shortcut to .Coordinator.AVTransportService.Stop()
     *
     * @returns {Promise<boolean>}
     * @memberof SonosDevice
     */
    Stop(): Promise<boolean>;
}
//# sourceMappingURL=sonos-device.d.ts.map