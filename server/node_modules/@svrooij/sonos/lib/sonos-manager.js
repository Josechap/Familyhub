"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const events_1 = require("events");
const services_1 = require("./services");
const sonos_device_1 = __importDefault(require("./sonos-device"));
const sonos_device_discovery_1 = __importDefault(require("./sonos-device-discovery"));
const models_1 = require("./models");
const ip_helper_1 = __importDefault(require("./helpers/ip-helper"));
const tts_helper_1 = __importDefault(require("./helpers/tts-helper"));
/**
 * The SonosManager will manage the logical devices for you. It will also manage group updates so be sure to call .Close on exit to remove open listeners.
 *
 * @export
 * @class SonosManager
 */
class SonosManager {
    constructor() {
        this.devices = [];
        this.zoneEventSubscription = this.handleZoneEventData.bind(this);
        this.events = new events_1.EventEmitter();
        this.debug = debug_1.default('sonos:sonosmanager');
    }
    /**
     * Initialize the manager with one known device. Useful in special network environments.
     *
     * @param {string} host
     * @param {number} [port=1400]
     * @returns {Promise<boolean>}
     * @memberof SonosManager
     */
    async InitializeFromDevice(host, port = 1400) {
        this.debug('InitializeFromDevice %s', host);
        const ip = ip_helper_1.default.IsIpv4(host) ? host : await ip_helper_1.default.ResolveHostname(host);
        this.zoneService = new services_1.ZoneGroupTopologyService(ip, port);
        return await this.Initialize();
    }
    /**
     * Initialize the manager by searching for one Sonos device in your network.
     *
     * @param {number} [timeoutInSeconds=10]
     * @returns {Promise<boolean>}
     * @memberof SonosManager
     */
    async InitializeWithDiscovery(timeoutInSeconds = 10, discovery = new sonos_device_discovery_1.default()) {
        this.debug('InitializeWithDiscovery timeout: %d', timeoutInSeconds);
        const player = await discovery.SearchOne(timeoutInSeconds);
        this.debug('Discovery found player with ip: %s', player.host);
        this.zoneService = new services_1.ZoneGroupTopologyService(player.host, player.port);
        return await this.Initialize();
    }
    async Initialize() {
        this.debug('Initialize()');
        const groups = await this.LoadAllGroups();
        const success = this.InitializeWithGroups(groups);
        return this.SubscribeForGroupEvents(success);
    }
    async LoadAllGroups() {
        if (this.zoneService === undefined)
            throw new Error('Manager is\'t initialized');
        return await this.zoneService.GetParsedZoneGroupState();
    }
    InitializeWithGroups(groups) {
        groups.forEach((g) => {
            const coordinator = new sonos_device_1.default(g.coordinator.host, g.coordinator.port, g.coordinator.uuid, g.coordinator.name, { name: g.name, managerEvents: this.events });
            if (this.devices.findIndex((v) => v.Uuid === coordinator.Uuid) === -1)
                this.devices.push(coordinator);
            g.members.forEach((m) => {
                // Check if device exists
                if (this.devices.findIndex((v) => v.Uuid === m.uuid) === -1) {
                    this.devices.push(new sonos_device_1.default(m.host, m.port, m.uuid, m.name, { coordinator: m.uuid === g.coordinator.uuid ? undefined : coordinator, name: g.name, managerEvents: this.events }));
                }
            });
        });
        return true;
    }
    SubscribeForGroupEvents(success) {
        if (success && this.zoneService) {
            this.zoneService.Events.on(models_1.ServiceEvents.ServiceEvent, this.zoneEventSubscription);
        }
        return success;
    }
    handleZoneEventData(data) {
        if (data.ZoneGroupState !== undefined && typeof data.ZoneGroupState !== 'string') {
            data.ZoneGroupState.forEach((g) => {
                let coordinator = this.devices.find((d) => d.Uuid === g.coordinator.uuid);
                if (coordinator === undefined) {
                    coordinator = new sonos_device_1.default(g.coordinator.host, g.coordinator.port, g.coordinator.uuid, g.coordinator.name, { coordinator: undefined, name: g.name, managerEvents: this.events });
                    this.devices.push(coordinator);
                    this.events.emit('NewDevice', coordinator);
                }
                // New members
                g.members
                    .filter((m) => !this.devices.some((d) => d.Uuid === m.uuid))
                    .forEach((m) => {
                    const newDevice = new sonos_device_1.default(m.host, m.port, m.uuid, m.name, { coordinator: m.uuid === g.coordinator.uuid ? undefined : coordinator, name: g.name, managerEvents: this.events });
                    this.devices.push(newDevice);
                    this.events.emit('NewDevice', newDevice);
                });
                g.members.forEach((m) => {
                    this.events.emit(m.uuid, { coordinator: g.coordinator.uuid === m.uuid ? undefined : coordinator, name: g.name });
                });
            });
        }
    }
    /**
     * Cancel the subscription (this will unsubscribe for zone events)
     *
     * @memberof SonosManager
     */
    CancelSubscription() {
        if (this.zoneService !== undefined)
            this.zoneService.Events.removeListener(models_1.ServiceEvents.ServiceEvent, this.zoneEventSubscription);
    }
    /**
     * Get all found devices, call InitializeWithDiscovery or InitializeFromDevice first.
     *
     * @readonly
     * @type {SonosDevice[]}
     * @memberof SonosManager
     */
    get Devices() {
        if (this.devices.length === 0)
            throw new Error('No Devices available!');
        return this.devices;
    }
    /**
     * Subscribe to receive new devices.
     *
     * @param {(device: SonosDevice) => void} listener
     * @memberof SonosManager
     */
    OnNewDevice(listener) {
        this.events.on('NewDevice', listener);
    }
    /**
     * Play a notification on all groups, without changing the current groups (for now).
     *
     * @param {PlayNotificationOptions} options The options
     * @param {string} options.trackUri The uri of the sound to play as notification, can be every supported sonos uri.
     * @param {string|Track} [options.metadata] The metadata of the track to play, will be guesses if undefined.
     * @param {number} [options.delayMs] Delay in ms between commands, for better notification playback stability
     * @param {boolean} [options.onlyWhenPlaying] Only play a notification if currently playing music. You don't have to check if the user is home ;)
     * @param {number} [options.timeout] Number of seconds the notification should play, as a fallback if the event doesn't come through.
     * @param {number} [options.volume] Change the volume for the notication and revert afterwards.
     * @returns {Promise<boolean>} Returns true is notification was played (and the state is set back to original)
     * @memberof SonosManager
     */
    async PlayNotification(options) {
        this.debug('PlayNotification(%o)', options);
        const commands = this.Devices
            .filter((d) => d.Coordinator.Uuid === d.Uuid)
            .map((d) => d.PlayNotification(options));
        return Promise
            .all(commands)
            .then((values) => values.some((v) => v));
    }
    /**
     * Play text to speech message on all groups, without changing the current groups (for now).
     *
     * @param {PlayTtsOptions} options
     * @param {string} options.text Text to request a TTS file for.
     * @param {string} options.lang Language to request tts file for.
     * @param {string} [options.endpoint] TTS endpoint, see documentation, can also be set by environment variable 'SONOS_TTS_ENDPOINT'
     * @param {string} [options.gender] Supply gender, some languages support both genders.
     * @param {string} [options.name] Supply voice name, some services support several voices with different names.
     * @param {number} [options.delayMs] Delay in ms between commands, for better notification playback stability
     * @param {boolean} [options.onlyWhenPlaying] Only play a notification if currently playing music. You don't have to check if the user is home ;)
     * @param {number} [options.timeout] Number of seconds the notification should play, as a fallback if the event doesn't come through.
     * @param {number} [options.volume] Change the volume for the notication and revert afterwards.
     * @returns {Promise<boolean>} returns true if notification actually played
     * @memberof SonosDevice
     */
    async PlayTTS(options) {
        this.debug('PlayTTS(%o)', options);
        const notificationOptions = await tts_helper_1.default.TtsOptionsToNotification(options);
        if (typeof (notificationOptions) === 'undefined') {
            return false;
        }
        return await this.PlayNotification(notificationOptions);
    }
    /**
     * Check the event subscriptions for all known devices.
     *
     * @returns {Promise<void>}
     * @memberof SonosManager
     */
    async CheckAllEventSubscriptions() {
        var _a;
        await ((_a = this.zoneService) === null || _a === void 0 ? void 0 : _a.CheckEventListener());
        await Promise.all(this.devices.map((device) => device.RefreshEventSubscriptions()));
    }
}
exports.default = SonosManager;
//# sourceMappingURL=sonos-manager.js.map